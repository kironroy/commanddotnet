{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction # Model your command line application interface in a class The purpose of this framework is to let developers focus on the core logic of command line application and forget about how arguments are parsed & validated . This library also let's you structure your CLI app into a hierarchy of commands and subcommands and invokes appropriate methods in your app based on user input. It provides out of the box CLI help with full customization options. Credits \ud83c\udf89 # Special thanks to Drew Burlingame for continuous support and contributions","title":"Introduction"},{"location":"#introduction","text":"Model your command line application interface in a class The purpose of this framework is to let developers focus on the core logic of command line application and forget about how arguments are parsed & validated . This library also let's you structure your CLI app into a hierarchy of commands and subcommands and invokes appropriate methods in your app based on user input. It provides out of the box CLI help with full customization options.","title":"Introduction"},{"location":"#credits","text":"Special thanks to Drew Burlingame for continuous support and contributions","title":"Credits \ud83c\udf89"},{"location":"argument-models/","text":"[ApplicationMetadata(Name=\"send\", Description=\"sends email\")] public void SendEmail ([ Option ] string subject , [ Option ( ShortName = \"a\" )] List < string > attachments , [ Option ] string body , [ Argument ] string from , [ Argument ] string to ) { } this can be invoked from the shell with: send --subject hi -a \"myFile.txt\" -a \"important.docx\" --body \"just wanted you to review these files\" bilal@bilal.com john@john.com The same arguments can be defined with a class: public class Email : IArgumentModel { [Option] public string Subject { get ; set ;} [Option(ShortName=\"a\")] public List < string > Attachments { get ; set ;} [Option] public string Body { get ; set ;} [Argument] public string From { get ; set ;} [Argument] public string To { get ; set ;} } and [ApplicationMetadata(Name=\"send\", Description=\"sends email\")] public void SendEmail ( Email email ) { } Benefits of argument models: # Common arguments can be extracted to models to enforce contracts across commands. ex. DryRunModel ensures the same short name, long name, description, etc are consistent across all commands using this model. FluentValidation framework can be used to validate the model Caveat # Argument position cannot be guaranteed to be consistent because the .Net Framework does not guarantee the order properties are reflected. The GetProperties method does not return properties in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which properties are returned, because that order varies. Order can differ on each machine the app is deployed to. This is not an issue with Option because options are positional Recommendation # Avoid modelling arguments in argument models unless you need to validate them using FluentValidation. If you do need to model arguments and you have scripts in place, verify the scripts work as expected on each new machine, after .net framework updates and after new deployments.","title":"Argument Models"},{"location":"argument-models/#benefits-of-argument-models","text":"Common arguments can be extracted to models to enforce contracts across commands. ex. DryRunModel ensures the same short name, long name, description, etc are consistent across all commands using this model. FluentValidation framework can be used to validate the model","title":"Benefits of argument models:"},{"location":"argument-models/#caveat","text":"Argument position cannot be guaranteed to be consistent because the .Net Framework does not guarantee the order properties are reflected. The GetProperties method does not return properties in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which properties are returned, because that order varies. Order can differ on each machine the app is deployed to. This is not an issue with Option because options are positional","title":"Caveat"},{"location":"argument-models/#recommendation","text":"Avoid modelling arguments in argument models unless you need to validate them using FluentValidation. If you do need to model arguments and you have scripts in place, verify the scripts work as expected on each new machine, after .net framework updates and after new deployments.","title":"Recommendation"},{"location":"async-methods/","text":"The following types of methods are supported : void int Task Task < int > async Task async Task < int > Task result types will be awaited automatically","title":"Async methods"},{"location":"attributes/","text":"ApplicationMetadata # You can use the [ ApplicationMetadata ] attribute on the class level like this to provide details when application is called with help switch. Example: [ApplicationMetadata(Description = \"This is a crappy calculator\", ExtendedHelpText = \"Some more help text that appears at the bottom\")] public class Calculator { } This attribute can also be used on a Method as shown below. [ApplicationMetadata(Description = \"Subtracts value2 from value1 and prints output\", ExtendedHelpText = \"Again, some more detailed help text which has no meaning I still have to write to demostrate this feature\", Name = \"subtractValues\")] public void Subtract ( int value1 , int value2 ) { } Tip When you use ApplicationMetadata attribute on a method, you can change the name of the command that is different from method name. SubCommand # [ SubCommand ] attribute indicates that targeted property is a SubCommand. See Nesting commands for examples Argument # Every parameter in the method is argument by default. So this this Attribute is optional and should be used only when you need to assign a different name to parameter, or add description to it. By default, the parameter names declared in method are the argument names that appear in help. However you can change that. Let's see an example- public void LaunchRocket ([ Argument ( Name = \"planet\" , Description = \"Name of the planet you wish the rocket to go)] string planetName) This is what help looks like- Usage: dotnet example.dll LaunchRocket [ arguments ] [ options ] Arguments: planetName String Name of the planet you wish the rocket to go Options: -h | -? | --help Show help information Option # Every parameter in the method is argument by default. So if you wan't to turn a parameter into option instead of argument, use this attribute. See more info about parameters here By default, the parameter names declared in method are the option names that appear in help. However you can change that. By convention, an option can have a short name and/or a long name. Let's see an example- public void LaunchRocket ([ Option ( LongName = \"planet\" , ShortName = \"p\" , Description = \"Name of the planet you wish the rocket to go\" )] string planetName ) This is what help looks like- Usage: dotnet example.dll LaunchRocket [ options ] Options: -h | -? | --help Show help information --planet | -p String Name of the planet you wish the rocket to go So planet name can now be passed either with --planet or - p . LongName, ShortName and Description are optional. When you don't specify a long name and a short name for an option, it uses the method parameter name by default as long name. In case the method parameter name is just one letter, it will be treated as short name. Here's table of examples: Method parameter name Longname Shortname Generated template planet --planet planet planet --planet planet p - p planet planet p - p | --planet p - p","title":"Attributes"},{"location":"attributes/#applicationmetadata","text":"You can use the [ ApplicationMetadata ] attribute on the class level like this to provide details when application is called with help switch. Example: [ApplicationMetadata(Description = \"This is a crappy calculator\", ExtendedHelpText = \"Some more help text that appears at the bottom\")] public class Calculator { } This attribute can also be used on a Method as shown below. [ApplicationMetadata(Description = \"Subtracts value2 from value1 and prints output\", ExtendedHelpText = \"Again, some more detailed help text which has no meaning I still have to write to demostrate this feature\", Name = \"subtractValues\")] public void Subtract ( int value1 , int value2 ) { } Tip When you use ApplicationMetadata attribute on a method, you can change the name of the command that is different from method name.","title":"ApplicationMetadata"},{"location":"attributes/#subcommand","text":"[ SubCommand ] attribute indicates that targeted property is a SubCommand. See Nesting commands for examples","title":"SubCommand"},{"location":"attributes/#argument","text":"Every parameter in the method is argument by default. So this this Attribute is optional and should be used only when you need to assign a different name to parameter, or add description to it. By default, the parameter names declared in method are the argument names that appear in help. However you can change that. Let's see an example- public void LaunchRocket ([ Argument ( Name = \"planet\" , Description = \"Name of the planet you wish the rocket to go)] string planetName) This is what help looks like- Usage: dotnet example.dll LaunchRocket [ arguments ] [ options ] Arguments: planetName String Name of the planet you wish the rocket to go Options: -h | -? | --help Show help information","title":"Argument"},{"location":"attributes/#option","text":"Every parameter in the method is argument by default. So if you wan't to turn a parameter into option instead of argument, use this attribute. See more info about parameters here By default, the parameter names declared in method are the option names that appear in help. However you can change that. By convention, an option can have a short name and/or a long name. Let's see an example- public void LaunchRocket ([ Option ( LongName = \"planet\" , ShortName = \"p\" , Description = \"Name of the planet you wish the rocket to go\" )] string planetName ) This is what help looks like- Usage: dotnet example.dll LaunchRocket [ options ] Options: -h | -? | --help Show help information --planet | -p String Name of the planet you wish the rocket to go So planet name can now be passed either with --planet or - p . LongName, ShortName and Description are optional. When you don't specify a long name and a short name for an option, it uses the method parameter name by default as long name. In case the method parameter name is just one letter, it will be treated as short name. Here's table of examples: Method parameter name Longname Shortname Generated template planet --planet planet planet --planet planet p - p planet planet p - p | --planet p - p","title":"Option"},{"location":"collections/","text":"Let's enhance our rocket launcher to support multiple planets. Collection of Options # public void LaunchRocket ([ Option ( ShortName = \"p\" )] List < string > planets ) This is what help information looks like- INPUT dotnet example.dll LaunchRocket --help OUTPUT Usage: dotnet example.dll LaunchRocket [ options ] Options: -h | -? | --help Show help information -p String ( Multiple ) And this is how you pass multiple options: dotnet example.dll LaunchRocket -p mars -p earth -p jupiter Collection of Arguments # public void LaunchRocket ( List < string > planets ) INPUT dotnet example.dll LaunchRocket --help OUTPUT Usage: dotnet example.dll LaunchRocket [ arguments ] [ options ] Arguments: planets String ( Multiple ) Options: -h | -? | --help Show help information And this is how you pass multiple arguments: dotnet example.dll LaunchRocket mars earth jupiter","title":"Collections"},{"location":"collections/#collection-of-options","text":"public void LaunchRocket ([ Option ( ShortName = \"p\" )] List < string > planets ) This is what help information looks like- INPUT dotnet example.dll LaunchRocket --help OUTPUT Usage: dotnet example.dll LaunchRocket [ options ] Options: -h | -? | --help Show help information -p String ( Multiple ) And this is how you pass multiple options: dotnet example.dll LaunchRocket -p mars -p earth -p jupiter","title":"Collection of Options"},{"location":"collections/#collection-of-arguments","text":"public void LaunchRocket ( List < string > planets ) INPUT dotnet example.dll LaunchRocket --help OUTPUT Usage: dotnet example.dll LaunchRocket [ arguments ] [ options ] Arguments: planets String ( Multiple ) Options: -h | -? | --help Show help information And this is how you pass multiple arguments: dotnet example.dll LaunchRocket mars earth jupiter","title":"Collection of Arguments"},{"location":"constructors/","text":"Let's say we want to add a class level field which is useful in both Addition and Subtraction. So now the class looks something like this- public class Calculator { private readonly bool _printValues ; public Calculator ( bool printValues ) { _printValues = printValues ; } [ApplicationMetadata(Description = \"Adds two numbers. duh!\")] public void Add ( int value1 , int value2 ) { if ( _printValues ) { Console . WriteLine ( $ \"value1 : {value1}, value2: {value2}\" ); } Console . WriteLine ( $ \"Answer: {value1 + value2}\" ); } public void Subtract ( int value1 , int value2 ) { if ( _printValues ) { Console . WriteLine ( $ \"value1 : {value1}, value2: {value2}\" ); } Console . WriteLine ( $ \"Answer: {value1 - value2}\" ); } } Let's see what the help command output looks like now INPUT dotnet example.dll --help OUTPUT Usage: dotnet example.dll [ options ] [ command ] Options: -h | -? | --help Show help information --printValues Flag Commands: Add Adds two numbers. duh! Subtract Use \"dotnet example.dll [command] --help\" for more information about a command. Let's try and invoke it INPUT dotnet example.dll --printValues Subtract 30 5 OUTPUT value1 : 30 , value2: 5 Answer: 25 Notes: You can skip to pass any parameter. It will then fallback to the default value of parameter type Any parameters in constructor are Options by default and you can't have Argument attribute in constructor parameters Only one constructor is supported. If there are multiple, it will pick up first defined constructor Inherited # [ Options ] attribute has a property called Inherited . This is particularly useful when used with constructor options. When set to true, that option is can be passed to commands as well.","title":"Constructors"},{"location":"constructors/#inherited","text":"[ Options ] attribute has a property called Inherited . This is particularly useful when used with constructor options. When set to true, that option is can be passed to commands as well.","title":"Inherited"},{"location":"custom-interceptors/","text":"Custom interceptors before method execution # Invoking the command method can be customized by implementing ICommandInvoker and registering the an instance with AppRunner.WithCommandInvoker. The WithCommandInvoker method provides the default implementation so it can be wrapped using the Decorator Pattern . static int Main ( string [] args ) { AppRunner < CustomCommandInvokerApp > appRunner = new AppRunner < CustomCommandInvokerApp >(). WithCommandInvoker ( inner => new CustomCommandInvoker ( inner )); return appRunner . Run ( args ); } public class CustomCommandInvoker : ICommandInvoker { private readonly ICommandInvoker _inner ; public CustomCommandInvoker ( ICommandInvoker inner ) { _inner = inner ; } public object Invoke ( CommandInvocation commandInvocation ) { // Your custom code here return _inner . Invoke ( commandInvocation ); } }","title":"Custom interceptors"},{"location":"custom-interceptors/#custom-interceptors-before-method-execution","text":"Invoking the command method can be customized by implementing ICommandInvoker and registering the an instance with AppRunner.WithCommandInvoker. The WithCommandInvoker method provides the default implementation so it can be wrapped using the Decorator Pattern . static int Main ( string [] args ) { AppRunner < CustomCommandInvokerApp > appRunner = new AppRunner < CustomCommandInvokerApp >(). WithCommandInvoker ( inner => new CustomCommandInvoker ( inner )); return appRunner . Run ( args ); } public class CustomCommandInvoker : ICommandInvoker { private readonly ICommandInvoker _inner ; public CustomCommandInvoker ( ICommandInvoker inner ) { _inner = inner ; } public object Invoke ( CommandInvocation commandInvocation ) { // Your custom code here return _inner . Invoke ( commandInvocation ); } }","title":"Custom interceptors before method execution"},{"location":"custom-return-codes/","text":"Typically when a console app exits with no erros, it returns 0 exit code. If there there was an error, it return 1 . But there are many possiblities and developers use this exit code to convey details about what exactly happenned. For example, https://msdn.microsoft.com/en-us/library/ms681381.aspx When you write a command line application you can return a custom return code. I added a new method in my Calculator to accept a number as input and exit the application with that number as exit code. [ApplicationMetadata(Description = \"Return with code 5\", Name = \"return\")] public int ReturnCode () { return 5 ; } So now when I call this method from console dotnet example . dll return , the command ends with an exit code of 5. Important Main method's return type should be int for this to work","title":"Custom return codes"},{"location":"default-method/","text":"Right now, when you just execute the dll, without any commands, it shows help. If you want to call a method when application is executed without any commands, you can do that with the help of [ DefaultMethod ] attribute. [DefaultMethod] public void SomeMethod () { } Some points to note about default method: It won't show up in help and can't be called explicitly with method name. The only way to execute it is not passing any command name It does not support any parameters It can have access to class level fields which are passed via constructor","title":"Default method"},{"location":"default-values/","text":"C# supports default values for parameters and so does this library. Let's make some changes to Calculator to add a new Command - Divide . And let's default value2 to 1 when user doesn't provide a value. This will prevent the calculator from crashing because of DivideByZeroException public void Divide ( int value1 , int value2 = 1 ) { Console . WriteLine ( $ \"Answer: {value1 / value2}\" ); } Here's how help looks like: INPUT dotnet example.dll Divide --help OUTPUT Usage: dotnet example.dll Divide [ arguments ] [ options ] Arguments: value1 Int32 value2 Int32 | Default value: 1 Options: -h | -? | --help Show help information","title":"Default values"},{"location":"dependency-injection/","text":"Let's say your app uses a service : public interface IService { int GetValue (); } public class Service : IService { public int GetValue () { return 4 ; } } Without dependency injection, app will have to create an instance of Service manually: public class App { public void PrintServiceValue () { IService service = new Service (); Console . WriteLine ( service . GetValue (). ToString ()); } } This looks simple now but because the Service class constructor doesn't have any constructor parameters but if it had, it would have been difficult for App to create the instance of Service . Another reason why you might want to use dependency injection is testable code. This is how App looks like with \"Property injection\" public class App { [InjectProperty] public IService Service { get ; set ;} public void PrintServiceValue () { Console . WriteLine ( Service . GetValue (). ToString ()); } } The benefit here is that you can mock IService and just test the behavior of App without worrying about Service class. CommandDotNet supports two IoC frameworks - Autofac & Microsoft Autofac # In order to use autofac, you need to install an additional integration nuget package : https://www.nuget.org/packages/CommandDotNet.IoC.Autofac/ This how you can use the package: static int Main ( string [] args ) { ContainerBuilder containerBuilder = new ContainerBuilder (); containerBuilder . RegisterType < Service >(). As < IService >(); IContainer container = containerBuilder . Build (); AppRunner < ServiceApp > appRunner = new AppRunner < ServiceApp >(). UseAutofac ( container ); return appRunner . Run ( args ); } Microsoft # In order to use Microsoft Dependency Injection, you need to install an additional integration nuget package : https://www.nuget.org/packages/CommandDotNet.IoC.MicrosoftDependencyInjection/ This how you can use the package: static int Main ( string [] args ) { IServiceCollection serviceCollection = new ServiceCollection (); serviceCollection . AddSingleton < IService , Service >(); IServiceProvider serviceProvider = serviceCollection . BuildServiceProvider (); AppRunner < ServiceApp > appRunner = new AppRunner < ServiceApp >(). UseMicrosoftDependencyInjection ( serviceProvider ) return appRunner . Run ( args ); }","title":"Dependency Injection"},{"location":"dependency-injection/#autofac","text":"In order to use autofac, you need to install an additional integration nuget package : https://www.nuget.org/packages/CommandDotNet.IoC.Autofac/ This how you can use the package: static int Main ( string [] args ) { ContainerBuilder containerBuilder = new ContainerBuilder (); containerBuilder . RegisterType < Service >(). As < IService >(); IContainer container = containerBuilder . Build (); AppRunner < ServiceApp > appRunner = new AppRunner < ServiceApp >(). UseAutofac ( container ); return appRunner . Run ( args ); }","title":"Autofac"},{"location":"dependency-injection/#microsoft","text":"In order to use Microsoft Dependency Injection, you need to install an additional integration nuget package : https://www.nuget.org/packages/CommandDotNet.IoC.MicrosoftDependencyInjection/ This how you can use the package: static int Main ( string [] args ) { IServiceCollection serviceCollection = new ServiceCollection (); serviceCollection . AddSingleton < IService , Service >(); IServiceProvider serviceProvider = serviceCollection . BuildServiceProvider (); AppRunner < ServiceApp > appRunner = new AppRunner < ServiceApp >(). UseMicrosoftDependencyInjection ( serviceProvider ) return appRunner . Run ( args ); }","title":"Microsoft"},{"location":"directives/","text":"Directives # Directives are special arguments enabling cross cutting features. We've followed the pattern defined by System.CommandLine to provide two directives: Debug & Parse new AppSettings { EnableDirectives = true } Directives must be the first argument and will be removed from further processing. Debug # Sometimes you just need to debug into a process and configuring the debug arguments in VS is too many extra steps. When you specify [ debug ] , the process id will output to the console and wait for you to attach a debugger. Attach your debugger to process 24236 ({ exe name }) . Parse # Rules for including spaces in arguments and escaping special characters differ from shell to shell. Sometimes it's not clear why arguments are not mapping correctly. When you specify [ parse ] , the process will exit immediately after printing each argument onto a new line. This enables you to catch cases where the shell did not parse your arguments as expected. Use [ parse : verbose ] to see changes after each TokenTransformation (expand-response-files, expand-clubbed-flags, split-option-assignments) to pinpoint which transformation resulted in unexpected changes.","title":"Directives"},{"location":"directives/#directives","text":"Directives are special arguments enabling cross cutting features. We've followed the pattern defined by System.CommandLine to provide two directives: Debug & Parse new AppSettings { EnableDirectives = true } Directives must be the first argument and will be removed from further processing.","title":"Directives"},{"location":"directives/#debug","text":"Sometimes you just need to debug into a process and configuring the debug arguments in VS is too many extra steps. When you specify [ debug ] , the process id will output to the console and wait for you to attach a debugger. Attach your debugger to process 24236 ({ exe name }) .","title":"Debug"},{"location":"directives/#parse","text":"Rules for including spaces in arguments and escaping special characters differ from shell to shell. Sometimes it's not clear why arguments are not mapping correctly. When you specify [ parse ] , the process will exit immediately after printing each argument onto a new line. This enables you to catch cases where the shell did not parse your arguments as expected. Use [ parse : verbose ] to see changes after each TokenTransformation (expand-response-files, expand-clubbed-flags, split-option-assignments) to pinpoint which transformation resulted in unexpected changes.","title":"Parse"},{"location":"exceptions/","text":"Any exception that is thrown from the method or constructor is thrown as is. You can catch it over the AppRunner < T > . Run () method otherwise exception will be unhandled and application will crash. try { AppRunner < Calculator > appRunner = new AppRunner < Calculator >(); return appRunner . Run ( args ); } catch ( MyBusinessException ex ) { Console . WriteLine ( ex . Message ); }","title":"Exceptions"},{"location":"fluent-validation-for-argument-models/","text":"You can use FluentValidation with this library to validate argument models . Here's an example, class Program { static int Main ( string [] args ) { AppRunner < ValidationApp > appRunner = new AppRunner < ValidationApp >(); return appRunner . Run ( args ); } } public class ValidationApp { public void ValidateModel ( PersonModel person ) { string content = JsonConvert . SerializeObject ( person , Formatting . Indented ); Console . WriteLine ( content ); } } [Validator(typeof(PersonValidator))] public class PersonModel : IArgumentModel { public int Id { get ; set ; } public string Name { get ; set ; } public string Email { get ; set ; } } public class PersonValidator : AbstractValidator < PersonModel > { public PersonValidator () { RuleFor ( x => x . Id ). GreaterThan ( 0 ); RuleFor ( x => x . Name ). NotEmpty (); RuleFor ( x => x . Email ). NotEmpty (). EmailAddress (); } } If the validation fails, app exits with return code 2 and prints validation error messages on screen.","title":"Fluent validation for parameters"},{"location":"nesting-commands/","text":"You can nest commands. Let's take git for example git has a command called stash. When you execute git stash , it stashes all the changes. But stash has further commands like, git stash pop , git stash list , etc. Let's try and mimic the same behavior using CommandDotNet: [ApplicationMetadata(Description = \"Fake git application\")] public class Git { [ApplicationMetadata(Description = \"Commits all staged changes\")] public void Commit ([ Option ( ShortName = \"m\" )] string commitMessage ) { Console . WriteLine ( \"Commit successful\" ); } [ApplicationMetadata(Description = \"Stashes all changes when executed without any arguments\")] [SubCommand] public class Stash { [DefaultMethod] public void StashDefaultCommand () { Console . WriteLine ( $ \"changes stashed\" ); } [ApplicationMetadata(Description = \"Applies last stashed changes\")] public void Pop () { Console . WriteLine ( $ \"stash popped\" ); } [ApplicationMetadata(Description = \"Lists all stashed changes\")] public void List () { Console . WriteLine ( $ \"here's the list of stash\" ); } } } Here's how the help looks like now: Fake git application Usage: dotnet example.dll [ options ] [ command ] Options: -h | -? | --help Show help information Commands: Commit Commits all staged changes Stash Stashes all changes when executed without any arguments Use \"dotnet example.dll [command] --help\" for more information about a command. Here's how the interaction looks like: INPUT dotnet example.dll commit -m \"some refactoring\" OUTPUT Commit successful INPUT dotnet example.dll stash OUTPUT changes stashed INPUT dotnet example.dll stash --help OUTPUT Stashes all changes when executed without any arguments Usage: dotnet example.dll Stash [ options ] [ command ] Options: -h | -? | --help Show help information Commands: List Lists all saved stashed changes Pop Applies last stashed changes Use \"Stash [command] --help\" for more information about a command. INPUT dotnet example.dll stash pop OUTPUT stash popped Alternative If you like to store your sub commands as external .cs files, you can that too with [ SubCommand ] attribute. [ApplicationMetadata(Description = \"Stashes all changes when executed without any arguments\")] public class Stash { [ApplicationMetadata(Description = \"Applies last stashed changes\")] public void Pop () { Console . WriteLine ( $ \"stash popped\" ); } } [ApplicationMetadata(Description = \"Fake git application\")] public class Git { [SubCommand] public Stash Stash { get ; set ;} // Stash class is saved in a seperate file [ApplicationMetadata(Description = \"Commits all staged changes\")] public void Commit ([ Option ( ShortName = \"m\" )] string commitMessage ) { Console . WriteLine ( \"Commit successful\" ); } }","title":"Nesting commands"},{"location":"parameter-types/","text":"Supports all types with a string constructor or where a TypeConverter is defined that can convert from a string. Includes, but not limited to: string char bool enum short int long decimal double Guid Uri FileInfo DirectoryInfo Also supports List < T > , IEnumerable < T > and Nullable < T > where T can be converted from string. Note: T [] is not currently supported. These are applicable for both - Options and Arguments Note for arguments: - There can be only one List argument in the method. It can be used with other non List type arguments or List type options. - If the method has a List type argument, it should be defined last in the order. Adding support for new types # In most cases, create a TypeConverter for your type If you need to override an existing TypeConverter conditional logic based on argument metadata (custom attributes, etc) the converter only for parsing parameters and not the business logic of your application Implement ITypedArgumentTypeDescriptor or IGenericArgumentTypeDescriptor and register with AppSettings . ArgumentTypeDescriptors . Register (...) .","title":"Parameter types"},{"location":"parameter-types/#adding-support-for-new-types","text":"In most cases, create a TypeConverter for your type If you need to override an existing TypeConverter conditional logic based on argument metadata (custom attributes, etc) the converter only for parsing parameters and not the business logic of your application Implement ITypedArgumentTypeDescriptor or IGenericArgumentTypeDescriptor and register with AppSettings . ArgumentTypeDescriptors . Register (...) .","title":"Adding support for new types"},{"location":"parameters/","text":"Arguments # Arguments are simple as we saw already in the introduction . Arguments are the main parameters of the command and should be as less as possible. If you compare them to a english statement, argument is the Subject of the sentence. Let try an example of an english sentence Please delete sample . docx file Now let's try and remove some extra words we don't need and convert it into command that system can understand. Let's say our command name is delete and its job is to delete files. We don't need the words please and file So we are left with delete sample . docx delete here is the name of command and sample.docx is the subject and hence the argument. C# method for the same would look like public void Delete ( string fileName ) We can have multiple subjects for instance, please delete sample . docx and number . xls . That would turn into delete sample . docx number . xls C# method for the same would look like public void Delete ( List < string > fileNames ) Options # Options are arguments that : - Are optional - Are named - May change behavior of command For instance let's just go with out example from arguments section. This time, the sentence is please delete the file sample . docx tomorrow . In this case, we have extra information about the operation we want to perform i.e. time The command is still delete , the subject(argument) is still sample . docx but the time has changed from now to tomorrow Let's see how we can translate into a cli command delete sample . docx --time tomorrow C# method for the same would look like public void Delete ( string fileName , [ Option ] string time = \"Now\" ) Flags # Flags are very similar to options except for the fact they are aways boolean (& false by default) and don't need an explicit value. If a flag is present, its true, otherwise it's false. Let's continue with same example as options , This time the sentence is Please delete the file sample . docx safely tomorrow . Safely here means that delete it only if no process is using it. It's naturally translated to a cli command as delete sample . docs --safely --time=tomorrow Tip Note that --time tomorrow , --time=tomorrow & --time:tomorrow are the same. Notice that we din't pass any value for --safely option. This is flag and it's value will be true since we have passed it. C# method for the same would look like public void Delete ( string fileName , [Option] bool safely , [Option] string time = \"Now\" )","title":"Parameters"},{"location":"parameters/#arguments","text":"Arguments are simple as we saw already in the introduction . Arguments are the main parameters of the command and should be as less as possible. If you compare them to a english statement, argument is the Subject of the sentence. Let try an example of an english sentence Please delete sample . docx file Now let's try and remove some extra words we don't need and convert it into command that system can understand. Let's say our command name is delete and its job is to delete files. We don't need the words please and file So we are left with delete sample . docx delete here is the name of command and sample.docx is the subject and hence the argument. C# method for the same would look like public void Delete ( string fileName ) We can have multiple subjects for instance, please delete sample . docx and number . xls . That would turn into delete sample . docx number . xls C# method for the same would look like public void Delete ( List < string > fileNames )","title":"Arguments"},{"location":"parameters/#options","text":"Options are arguments that : - Are optional - Are named - May change behavior of command For instance let's just go with out example from arguments section. This time, the sentence is please delete the file sample . docx tomorrow . In this case, we have extra information about the operation we want to perform i.e. time The command is still delete , the subject(argument) is still sample . docx but the time has changed from now to tomorrow Let's see how we can translate into a cli command delete sample . docx --time tomorrow C# method for the same would look like public void Delete ( string fileName , [ Option ] string time = \"Now\" )","title":"Options"},{"location":"parameters/#flags","text":"Flags are very similar to options except for the fact they are aways boolean (& false by default) and don't need an explicit value. If a flag is present, its true, otherwise it's false. Let's continue with same example as options , This time the sentence is Please delete the file sample . docx safely tomorrow . Safely here means that delete it only if no process is using it. It's naturally translated to a cli command as delete sample . docs --safely --time=tomorrow Tip Note that --time tomorrow , --time=tomorrow & --time:tomorrow are the same. Notice that we din't pass any value for --safely option. This is flag and it's value will be true since we have passed it. C# method for the same would look like public void Delete ( string fileName , [Option] bool safely , [Option] string time = \"Now\" )","title":"Flags"},{"location":"quick-start/","text":"Installation # CommandDotNet can be installed from nuget.org .NET CLI dotnet add package CommandDotNet Nuget Package Manager Install-Package CommandDotNet Let's build a calculator # Let's say you want to create a calculator console application which can perform 2 operations: Addition Subtraction It prints the results on console. Let's begin with creating the class public class Calculator { public void Add ( int value1 , int value2 ) { Console . WriteLine ( $ \"Answer: {value1 + value2}\" ); } public void Subtract ( int value1 , int value2 ) { Console . WriteLine ( $ \"Answer: {value1 - value2}\" ); } } Now that we have our calculator ready, let's see about how we can call it from command line. class Program { static int Main ( string [] args ) { AppRunner < Calculator > appRunner = new AppRunner < Calculator >(); return appRunner . Run ( args ); } } Assuming our application's name is example . dll let's try and run this app from command line using dotnet INPUT dotnet example.dll --help OUTPUT Usage: dotnet example.dll [ options ] [ command ] Options: -h | -? | --help Show help information Commands: Add Subtract Use \"dotnet example.dll [command] --help\" for more information about a command. Voila! So, as you might have already guessed, it is detecting methods of the calculator class. How about adding some helpful description. [ApplicationMetadata(Description = \"Adds two numbers. duh!\")] public void Add ( int value1 , int value2 ) { Console . WriteLine ( $ \"Answer: {value1 + value2}\" ); } This should do it. Let's see how the help appears now. Usage: dotnet example.dll [ options ] [ command ] Options: -h | -? | --help Show help information Commands: Add Adds two numbers. duh! Subtract Use \"dotnet example.dll [command] --help\" for more information about a command. Awesome. Descriptions are not required but can be very useful depending upon the complexity of your app and the audience. Now let's try to see if we can get further help for the add command. INPUT dotnet example.dll Add --help OUTPUT Usage: dotnet example.dll Add [ arguments ] [ options ] Arguments: value1 Int32 value2 Int32 Options: -h | -? | --help Show help information tada! Ok, so here, it show what parameters are required for addition and their type. Let's try and add two numbers. INPUT dotnet example.dll Add 40 20 OUTPUT Answer: 60 Cool. You get the gist of this library. Let's move on.","title":"Quick Start"},{"location":"quick-start/#installation","text":"CommandDotNet can be installed from nuget.org .NET CLI dotnet add package CommandDotNet Nuget Package Manager Install-Package CommandDotNet","title":"Installation"},{"location":"quick-start/#lets-build-a-calculator","text":"Let's say you want to create a calculator console application which can perform 2 operations: Addition Subtraction It prints the results on console. Let's begin with creating the class public class Calculator { public void Add ( int value1 , int value2 ) { Console . WriteLine ( $ \"Answer: {value1 + value2}\" ); } public void Subtract ( int value1 , int value2 ) { Console . WriteLine ( $ \"Answer: {value1 - value2}\" ); } } Now that we have our calculator ready, let's see about how we can call it from command line. class Program { static int Main ( string [] args ) { AppRunner < Calculator > appRunner = new AppRunner < Calculator >(); return appRunner . Run ( args ); } } Assuming our application's name is example . dll let's try and run this app from command line using dotnet INPUT dotnet example.dll --help OUTPUT Usage: dotnet example.dll [ options ] [ command ] Options: -h | -? | --help Show help information Commands: Add Subtract Use \"dotnet example.dll [command] --help\" for more information about a command. Voila! So, as you might have already guessed, it is detecting methods of the calculator class. How about adding some helpful description. [ApplicationMetadata(Description = \"Adds two numbers. duh!\")] public void Add ( int value1 , int value2 ) { Console . WriteLine ( $ \"Answer: {value1 + value2}\" ); } This should do it. Let's see how the help appears now. Usage: dotnet example.dll [ options ] [ command ] Options: -h | -? | --help Show help information Commands: Add Adds two numbers. duh! Subtract Use \"dotnet example.dll [command] --help\" for more information about a command. Awesome. Descriptions are not required but can be very useful depending upon the complexity of your app and the audience. Now let's try to see if we can get further help for the add command. INPUT dotnet example.dll Add --help OUTPUT Usage: dotnet example.dll Add [ arguments ] [ options ] Arguments: value1 Int32 value2 Int32 Options: -h | -? | --help Show help information tada! Ok, so here, it show what parameters are required for addition and their type. Let's try and add two numbers. INPUT dotnet example.dll Add 40 20 OUTPUT Answer: 60 Cool. You get the gist of this library. Let's move on.","title":"Let's build a calculator"},{"location":"settings/","text":"When you create a new instance of AppRunner < T > you can pass an instance new AppSettings object. Here are the settings you can change: Show argument details # Shows type information of arguments in help text. Enabled by default. Method argument mode # Possible values : Parameter (default) Option When method argument mode is set to parameter, all arguments of methods are treated as parameters and don't need any names to be passed through command line. Caution Order of passing parameters matter in this mode When method argument mode is set to option, all arguments of methods are treated as options and need a name to be passed. Important This is only applicable for methods and not constructors. For constructors, all arguments are options only Enable version option # True by default. It adds an additional option to the root command. It shows version of the application. Case # public class SomeClass { public SomeClass ( string Url ) { } public void ProcessRequest () { } } by default this would result into something like this: Usage: dotnet example.dll [ options ] [ command ] Options: -h | -? | --help Show help information --Url String Commands: ProcessRequest Use \"dotnet example.dll [command] --help\" for more information about a command. Command line conventions are different from C# conventions and the usual pascal casing of method names or camel casing of parameter names may not be suitable for command line arguments. You can continue to develop you classes and method in normal C# conventions and tell library to transform them into the desired casing. There are 5 modes available: DontChange LowerCase CamelCase KebabCase PascalCase If you now use a different setting, class Program { static int Main ( string [] args ) { AppRunner < SomeClass > appRunner = new AppRunner < SomeClass >( new AppSettings { Case = Case . KebabCase }); return appRunner . Run ( args ); } } The result would something like this: Usage: dotnet example.dll [ options ] [ command ] Options: -h | -? | --help Show help information --url String Commands: process-request Use \"dotnet example.dll [command] --help\" for more information about a command. Note This would not transform any name that you have overridden via [ ApplicationMetadata ] , [ Option ] or [ Argument ] attributes. Boolean mode # In this library, there are two ways to parse boolean Options Note Boolean mod is applicable only for Options and not for Arguments 1. Implicit # This is the default mode. In this mode, you don't pass the value true or false in the command line. These parameters are treated as flags. They are considered true if they are present and false when they are not. For example: dotnet example.dll --printValues In this case, value of parameter printValues will be true and in the following example, dotnet example.dll value of parameter printValues will be false. Note When using implicit boolean mode, it will result in an error, if the user tries to explicitly enter a value for parameter. In this instance, dotnet example . dll --printValues true will result into an error. When you check the help of a command, you if you see Flag for a parameter, it means value is implit and does not require an explicit one. Flag clubbing # Clubbing of one letter options is supported. For example, If a command has multiple boolean flags options like: public void Print ([ Option ( ShortName = \"c\" )] bool qwerty , bool e , bool x ){ } These can be passed either as dotnet example.dll print -c -e -x OR dotnet example.dll print -ecx 2. Explicit # If you want users to explicitly enter true or false, you need to set the boolean mode explicit. You can do that, by using the [ Argument ] attribute as shown below: public void MyCommand ([ Argument ( BooleanMode = BooleanMode . Explicit )] bool capturelogs ) { } Note You can set BooleanMode = BooleanMode . Implicit or BooleanMode = BooleanMode . Explicit only for bool or bool ? type options. When you use explicit boolean mode, these scenarios are valid: dotnet example.dll MyCommand dotnet example.dll MyCommand --capturelogs false dotnet example.dll MyCommand --capturelogs true but dotnet example . dll MyCommand --capturelogs is not valid and will result into error. It will only work in Implicit boolean mode. When you check the help of a command, and you see Boolean it means if you wan't to make it true, you need to pass an explicit value. If you don't pass one, it will default to false automatically. Implicit and explicit are just ways to pass the value, under the hood they are just boolean parameters.","title":"Settings"},{"location":"settings/#show-argument-details","text":"Shows type information of arguments in help text. Enabled by default.","title":"Show argument details"},{"location":"settings/#method-argument-mode","text":"Possible values : Parameter (default) Option When method argument mode is set to parameter, all arguments of methods are treated as parameters and don't need any names to be passed through command line. Caution Order of passing parameters matter in this mode When method argument mode is set to option, all arguments of methods are treated as options and need a name to be passed. Important This is only applicable for methods and not constructors. For constructors, all arguments are options only","title":"Method argument mode"},{"location":"settings/#enable-version-option","text":"True by default. It adds an additional option to the root command. It shows version of the application.","title":"Enable version option"},{"location":"settings/#case","text":"public class SomeClass { public SomeClass ( string Url ) { } public void ProcessRequest () { } } by default this would result into something like this: Usage: dotnet example.dll [ options ] [ command ] Options: -h | -? | --help Show help information --Url String Commands: ProcessRequest Use \"dotnet example.dll [command] --help\" for more information about a command. Command line conventions are different from C# conventions and the usual pascal casing of method names or camel casing of parameter names may not be suitable for command line arguments. You can continue to develop you classes and method in normal C# conventions and tell library to transform them into the desired casing. There are 5 modes available: DontChange LowerCase CamelCase KebabCase PascalCase If you now use a different setting, class Program { static int Main ( string [] args ) { AppRunner < SomeClass > appRunner = new AppRunner < SomeClass >( new AppSettings { Case = Case . KebabCase }); return appRunner . Run ( args ); } } The result would something like this: Usage: dotnet example.dll [ options ] [ command ] Options: -h | -? | --help Show help information --url String Commands: process-request Use \"dotnet example.dll [command] --help\" for more information about a command. Note This would not transform any name that you have overridden via [ ApplicationMetadata ] , [ Option ] or [ Argument ] attributes.","title":"Case"},{"location":"settings/#boolean-mode","text":"In this library, there are two ways to parse boolean Options Note Boolean mod is applicable only for Options and not for Arguments","title":"Boolean mode"},{"location":"settings/#1-implicit","text":"This is the default mode. In this mode, you don't pass the value true or false in the command line. These parameters are treated as flags. They are considered true if they are present and false when they are not. For example: dotnet example.dll --printValues In this case, value of parameter printValues will be true and in the following example, dotnet example.dll value of parameter printValues will be false. Note When using implicit boolean mode, it will result in an error, if the user tries to explicitly enter a value for parameter. In this instance, dotnet example . dll --printValues true will result into an error. When you check the help of a command, you if you see Flag for a parameter, it means value is implit and does not require an explicit one.","title":"1.  Implicit"},{"location":"settings/#flag-clubbing","text":"Clubbing of one letter options is supported. For example, If a command has multiple boolean flags options like: public void Print ([ Option ( ShortName = \"c\" )] bool qwerty , bool e , bool x ){ } These can be passed either as dotnet example.dll print -c -e -x OR dotnet example.dll print -ecx","title":"Flag clubbing"},{"location":"settings/#2-explicit","text":"If you want users to explicitly enter true or false, you need to set the boolean mode explicit. You can do that, by using the [ Argument ] attribute as shown below: public void MyCommand ([ Argument ( BooleanMode = BooleanMode . Explicit )] bool capturelogs ) { } Note You can set BooleanMode = BooleanMode . Implicit or BooleanMode = BooleanMode . Explicit only for bool or bool ? type options. When you use explicit boolean mode, these scenarios are valid: dotnet example.dll MyCommand dotnet example.dll MyCommand --capturelogs false dotnet example.dll MyCommand --capturelogs true but dotnet example . dll MyCommand --capturelogs is not valid and will result into error. It will only work in Implicit boolean mode. When you check the help of a command, and you see Boolean it means if you wan't to make it true, you need to pass an explicit value. If you don't pass one, it will default to false automatically. Implicit and explicit are just ways to pass the value, under the hood they are just boolean parameters.","title":"2. Explicit"},{"location":"V3/cancellation/","text":"Ctrl+C and CancellationToken # Console applications should stop gracefully when the user enters Ctrl + C or Ctrl + Break . If your app is consuming the main thread the app will not exit right away. Traditionally, this is solved with a following steps: Create a CancellationTokenSource and make the cancellationTokenSource . Token available for the rest of the app to reference. Subscribe to Console . CancelKeyPress and call cancellationTokenSource . Cancel () when triggered. cancellationToken . IsCancellationRequested will then return true. Check cancellationToken . IsCancellationRequested in any looping code and pass the token to any libraries that check it. Instead of Thread . Sleep (...) , use cancellationToken . WaitHandle . WaitOne (...) or Task . Delay (..., cancellationToken ) Cancellation middleware # CommandDotNet has middleware to simplify this. Configure with appRunner . UseCancellationHandlers (); . The framework will: set the CommandContext . AppConfig . CancellationToken with a new token. the token will be cancelled on Console . CancelKepPress AppDomain . CurrentDomain . ProcessExit AppDomain . CurrentDomain . UnhandledException when UnhandledExceptionEventArgs . IsTerminating == true The framework checks the cancellation token before every step in the pipeline. Using the CancellationToken # The CancellationToken is easy to access in your commands thanks to parameter resolvers . Simply add a parameter to your command or interceptor method. public void MigrateRecords ( CancellationToken cancellationToken , List < int > ids ) { foreach ( int id in ids . TakeWhile (! cancellationToken . IsCancellationRequested )) { MigrateRecord ( id ); } } Remember to pass the CancellationToken to all database, web and other service requests that take one.","title":"Ctrl+C and CancellationToken"},{"location":"V3/cancellation/#ctrlc-and-cancellationtoken","text":"Console applications should stop gracefully when the user enters Ctrl + C or Ctrl + Break . If your app is consuming the main thread the app will not exit right away. Traditionally, this is solved with a following steps: Create a CancellationTokenSource and make the cancellationTokenSource . Token available for the rest of the app to reference. Subscribe to Console . CancelKeyPress and call cancellationTokenSource . Cancel () when triggered. cancellationToken . IsCancellationRequested will then return true. Check cancellationToken . IsCancellationRequested in any looping code and pass the token to any libraries that check it. Instead of Thread . Sleep (...) , use cancellationToken . WaitHandle . WaitOne (...) or Task . Delay (..., cancellationToken )","title":"Ctrl+C and CancellationToken"},{"location":"V3/cancellation/#cancellation-middleware","text":"CommandDotNet has middleware to simplify this. Configure with appRunner . UseCancellationHandlers (); . The framework will: set the CommandContext . AppConfig . CancellationToken with a new token. the token will be cancelled on Console . CancelKepPress AppDomain . CurrentDomain . ProcessExit AppDomain . CurrentDomain . UnhandledException when UnhandledExceptionEventArgs . IsTerminating == true The framework checks the cancellation token before every step in the pipeline.","title":"Cancellation middleware"},{"location":"V3/cancellation/#using-the-cancellationtoken","text":"The CancellationToken is easy to access in your commands thanks to parameter resolvers . Simply add a parameter to your command or interceptor method. public void MigrateRecords ( CancellationToken cancellationToken , List < int > ids ) { foreach ( int id in ids . TakeWhile (! cancellationToken . IsCancellationRequested )) { MigrateRecord ( id ); } } Remember to pass the CancellationToken to all database, web and other service requests that take one.","title":"Using the CancellationToken"},{"location":"V3/interceptors/","text":"Interceptor methods # Interceptor methods provide a way to define a method that will be executed for all subcommands, as well as the current command if it contains a default method. Interceptor methods can define options to be provided in the shell. Interceptors cannot define arguments because they are positional and positional arguments are not allowed when a subcommand is requested. Example: Using the following commands, we can request the mathematical base to use for our calculations in one location and all subcommands will use the same base. In the shell: dotnet calculator --radix 2 Add 1 2 public class Calculator { private iCalculator _calculator ; public Task < int > Interceptor ( InterceptorExecutionDelegate next , int radix ) { _calculator = Factory . GetCalculatorFor ( radix ); return next (); } [Command(Description = \"Adds two numbers\")] public void Add ( int x , int y , IConsole console ) { console . WriteLine ( _calculator . Add ( x , y )); } [Command(Description = \"Subtracts the second number from the first\")] public void Subtract ( int x , int x , IConsole console ) { console . WriteLine ( _calculator . Subtract ( y , y )); } } Inherited options # Inherited options provide a way to specify the interceptor option in the executed subcommand. Using the previous example, change int radix to [ Option ( Inherited = true )] int radix Now in the shell: dotnet calculator Add 1 2 --radix 2 public class Calculator { private iCalculator _calculator ; public Task < int > Interceptor ( InterceptorExecutionDelegate next , [Option(Inherited = true)] int radix ) { _calculator = Factory . GetCalculatorFor ( radix ); return next (); } [Command(Description = \"Adds two numbers\")] public void Add ( int value1 , int value2 , IConsole console ) { console . WriteLine ( _calculator . Add ( value1 , value2 )); } [Command(Description = \"Subtracts the second number from the first\")] public void Subtract ( int value1 , int value2 , IConsole console ) { console . WriteLine ( _calculator . Subtract ( value1 , value2 )); } } Additional parameters # In addition to defining options, interceptor methods can define parameters of type: CommandContext IConsole CancellationToken Hooks for your commands # Wrap return next () ; in try/catch/finally statements and use the interceptor as pre and post hooks for your commands.","title":"Interceptor methods"},{"location":"V3/interceptors/#interceptor-methods","text":"Interceptor methods provide a way to define a method that will be executed for all subcommands, as well as the current command if it contains a default method. Interceptor methods can define options to be provided in the shell. Interceptors cannot define arguments because they are positional and positional arguments are not allowed when a subcommand is requested. Example: Using the following commands, we can request the mathematical base to use for our calculations in one location and all subcommands will use the same base. In the shell: dotnet calculator --radix 2 Add 1 2 public class Calculator { private iCalculator _calculator ; public Task < int > Interceptor ( InterceptorExecutionDelegate next , int radix ) { _calculator = Factory . GetCalculatorFor ( radix ); return next (); } [Command(Description = \"Adds two numbers\")] public void Add ( int x , int y , IConsole console ) { console . WriteLine ( _calculator . Add ( x , y )); } [Command(Description = \"Subtracts the second number from the first\")] public void Subtract ( int x , int x , IConsole console ) { console . WriteLine ( _calculator . Subtract ( y , y )); } }","title":"Interceptor methods"},{"location":"V3/interceptors/#inherited-options","text":"Inherited options provide a way to specify the interceptor option in the executed subcommand. Using the previous example, change int radix to [ Option ( Inherited = true )] int radix Now in the shell: dotnet calculator Add 1 2 --radix 2 public class Calculator { private iCalculator _calculator ; public Task < int > Interceptor ( InterceptorExecutionDelegate next , [Option(Inherited = true)] int radix ) { _calculator = Factory . GetCalculatorFor ( radix ); return next (); } [Command(Description = \"Adds two numbers\")] public void Add ( int value1 , int value2 , IConsole console ) { console . WriteLine ( _calculator . Add ( value1 , value2 )); } [Command(Description = \"Subtracts the second number from the first\")] public void Subtract ( int value1 , int value2 , IConsole console ) { console . WriteLine ( _calculator . Subtract ( value1 , value2 )); } }","title":"Inherited options"},{"location":"V3/interceptors/#additional-parameters","text":"In addition to defining options, interceptor methods can define parameters of type: CommandContext IConsole CancellationToken","title":"Additional parameters"},{"location":"V3/interceptors/#hooks-for-your-commands","text":"Wrap return next () ; in try/catch/finally statements and use the interceptor as pre and post hooks for your commands.","title":"Hooks for your commands"},{"location":"V3/middleware/","text":"Middleware Pipeline # The architecture uses a middleware pipeline, similar to ASP.NET Core and System.CommandLine . The middleware pipeline is a type of chain of responsibilty pattern . Middleware are components that register a delegate as a step in the pipeline. The delegate is called by the previous delegate and in turn calls the next delegate. With this pattern, a middleware can perform work before and after the call to the next delegate or skip the next delegate if appropriate. Take the Help middleware for example. When - h , --help or -? been specified, the help middleware prints help for the target command and does not call the next middleware. As the middleware executes, it enhances the CommandContext . The CommandContext contains the context relevate to the current command. For example... the tokenizer middleware populates the CommandContext . Tokens property. The parser middleware populates the CommandContext . ParseResults property. The CommandContext is part of the delegate signature and is therefore available for all middleware. Why we use the middleware pattern # Ease of adding new features without touching existing code. Observing Single Resposibility & Open-Closed principals. Ease of extending the framework using external packages. Supports community enhancements while reducing the bloat of this code base. Feature tests can exclude middleware that's not relevant to the tests. Alignment with System.CommandLine architecture, making it easier to integrate if it moves beyond the experimental phase. Middleware Stages # The core functionality of the framework has been implemented using middleware. Optional features have also been implemented using middleware. One of the classic challenges of using the middleware pattern is understanding the order middleware components should be registered. To address this challenge, the pipeline has been split into ten distinct changes, as seen in the diagram below, five core stages (in green) and five extensibility stages (in yellow). The five core stages contain the core functionality of the framework. After each core stage is complete, the framework guarantees specific parts of the CommandContext are populated. The other 5 stages are where other middleware will typically be registered, based on the CommandContext properties the middleware requires to operate. For example, PromptForMissingOperands is registered in the PostParseInputPreBindValues stage because it depends on the ParseResults . ArgumentValues property being populated in the ParseInput stage. FluentValidation is registerd in the PostBindValuesPreInvoke stage because it relies on the IInvocation . ParameterValues being populated in the BindValues stage. Read more in the intellisense of MiddlewareStages and the properties of the CommandContext classes. Note: DisplayVersion is the only optional middleware in a core stage. Any middleware can be register core stage if needed. In the case of DisplayVersion , the middleware must run before DisplayHelp otherwise help would trigger for the root command because it's not executable. DisplayVersion is able to identify the version option was specified and short circuit the pipeline after printing version information. Invocation Pipeline # The invocation pipeline is assembled during the ParseInput stage, captured in CommandContext . InvocationPipeline property and run during the InvokeInvocationPipeline stage. The pipeline consists of interceptor methods and the target command method.","title":"Middleware Pipeline"},{"location":"V3/middleware/#middleware-pipeline","text":"The architecture uses a middleware pipeline, similar to ASP.NET Core and System.CommandLine . The middleware pipeline is a type of chain of responsibilty pattern . Middleware are components that register a delegate as a step in the pipeline. The delegate is called by the previous delegate and in turn calls the next delegate. With this pattern, a middleware can perform work before and after the call to the next delegate or skip the next delegate if appropriate. Take the Help middleware for example. When - h , --help or -? been specified, the help middleware prints help for the target command and does not call the next middleware. As the middleware executes, it enhances the CommandContext . The CommandContext contains the context relevate to the current command. For example... the tokenizer middleware populates the CommandContext . Tokens property. The parser middleware populates the CommandContext . ParseResults property. The CommandContext is part of the delegate signature and is therefore available for all middleware.","title":"Middleware Pipeline"},{"location":"V3/middleware/#why-we-use-the-middleware-pattern","text":"Ease of adding new features without touching existing code. Observing Single Resposibility & Open-Closed principals. Ease of extending the framework using external packages. Supports community enhancements while reducing the bloat of this code base. Feature tests can exclude middleware that's not relevant to the tests. Alignment with System.CommandLine architecture, making it easier to integrate if it moves beyond the experimental phase.","title":"Why we use the middleware pattern"},{"location":"V3/middleware/#middleware-stages","text":"The core functionality of the framework has been implemented using middleware. Optional features have also been implemented using middleware. One of the classic challenges of using the middleware pattern is understanding the order middleware components should be registered. To address this challenge, the pipeline has been split into ten distinct changes, as seen in the diagram below, five core stages (in green) and five extensibility stages (in yellow). The five core stages contain the core functionality of the framework. After each core stage is complete, the framework guarantees specific parts of the CommandContext are populated. The other 5 stages are where other middleware will typically be registered, based on the CommandContext properties the middleware requires to operate. For example, PromptForMissingOperands is registered in the PostParseInputPreBindValues stage because it depends on the ParseResults . ArgumentValues property being populated in the ParseInput stage. FluentValidation is registerd in the PostBindValuesPreInvoke stage because it relies on the IInvocation . ParameterValues being populated in the BindValues stage. Read more in the intellisense of MiddlewareStages and the properties of the CommandContext classes. Note: DisplayVersion is the only optional middleware in a core stage. Any middleware can be register core stage if needed. In the case of DisplayVersion , the middleware must run before DisplayHelp otherwise help would trigger for the root command because it's not executable. DisplayVersion is able to identify the version option was specified and short circuit the pipeline after printing version information.","title":"Middleware Stages"},{"location":"V3/middleware/#invocation-pipeline","text":"The invocation pipeline is assembled during the ParseInput stage, captured in CommandContext . InvocationPipeline property and run during the InvokeInvocationPipeline stage. The pipeline consists of interceptor methods and the target command method.","title":"Invocation Pipeline"},{"location":"V3/parameter-resolvers/","text":"Parameter Resolvers # Parameters defined in command and interceptor methods must a type as defined in parameter-types . There are times where your command method needs to write to the IConsole or perform a loop while checking the CancellationToken . To get these, you define an interceptor method with a CommandContext parameter and copy the properties to fields for use in other methods. This quickly gets cumbersome. The answer... parameter resolvers, functions that, given a CommandContext , return an instance of a type that can be passed to a command or interceptor method. There are three default resolvers for CommandContext , IConsole & CancellationToken More can be registered like this appRunner . Configure ( b => b . UseParameterResolver ( ctx => ctx . Services . Get < SomeClass >())); These types are now available as parameters for command methods, interceptor methods and command class constructors. public class Calculator { private iCalculator _calculator ; public Task < int > Interceptor ( InterceptorExecutionDelegate next , [Option(Inherited = true)] int radix , SomeClass someClass ) { _calculator = Factory . GetCalculatorFor ( radix ); return next (); } [Command(Description = \"Adds two numbers\")] public void Add ( int value1 , int value2 , IConsole console ) { console . WriteLine ( _calculator . Add ( value1 , value2 )); } [Command(Description = \"Subtracts the second number from the first\")] public void Subtract ( int value1 , int value2 , IConsole console ) { console . WriteLine ( _calculator . Subtract ( value1 , value2 )); } }","title":"Parameter Resolvers"},{"location":"V3/parameter-resolvers/#parameter-resolvers","text":"Parameters defined in command and interceptor methods must a type as defined in parameter-types . There are times where your command method needs to write to the IConsole or perform a loop while checking the CancellationToken . To get these, you define an interceptor method with a CommandContext parameter and copy the properties to fields for use in other methods. This quickly gets cumbersome. The answer... parameter resolvers, functions that, given a CommandContext , return an instance of a type that can be passed to a command or interceptor method. There are three default resolvers for CommandContext , IConsole & CancellationToken More can be registered like this appRunner . Configure ( b => b . UseParameterResolver ( ctx => ctx . Services . Get < SomeClass >())); These types are now available as parameters for command methods, interceptor methods and command class constructors. public class Calculator { private iCalculator _calculator ; public Task < int > Interceptor ( InterceptorExecutionDelegate next , [Option(Inherited = true)] int radix , SomeClass someClass ) { _calculator = Factory . GetCalculatorFor ( radix ); return next (); } [Command(Description = \"Adds two numbers\")] public void Add ( int value1 , int value2 , IConsole console ) { console . WriteLine ( _calculator . Add ( value1 , value2 )); } [Command(Description = \"Subtracts the second number from the first\")] public void Subtract ( int value1 , int value2 , IConsole console ) { console . WriteLine ( _calculator . Subtract ( value1 , value2 )); } }","title":"Parameter Resolvers"},{"location":"V3/piped-arguments/","text":"Piped Arguments # What is piping? # Piping is a way to pass the console output of a command to another another command. A simple example is searching the history of your bash commands for git commands: history | grep git . The pipe | tells the shell you are running a new command and that the new command will take the output of the previous command. In this case, history will output the last N bash commands and grep git will filter the output to only the commands containing \"git\" Piping is a great way to decompose commands into smaller, single-responsibility commands. Tip When you find commands repeating the same options to determine what items to operate on, consider extracting the options into search command that returns ids and then update the other commands take the list of ids. In .net console apps, you can check piped input using Console . IsInputRedirected and Console . In . Read___ () . Or... use our provided middleware Using the middleware? # First, enable the feature with appRunner . AppendPipedInputToOperandList () . Every command is allowed a single operand list. If one is defined and if piped input is available, it will be appended to this list. If the user provides values for the operand and pipes input, the two sources will be concatenated, with piped input at the end. Tip All output to the console is piped to the next command. Be sure the command does not include additional logging information. Caveat The middleware will currently read all piped input before processing the command. This will require the first command to completely finish before the second command starts so this is not yet suitable for streaming. We hope to resolve this in a future release. If you need streaming, please consider helping us enhance this middleware.","title":"Piped Arguments"},{"location":"V3/piped-arguments/#piped-arguments","text":"","title":"Piped Arguments"},{"location":"V3/piped-arguments/#what-is-piping","text":"Piping is a way to pass the console output of a command to another another command. A simple example is searching the history of your bash commands for git commands: history | grep git . The pipe | tells the shell you are running a new command and that the new command will take the output of the previous command. In this case, history will output the last N bash commands and grep git will filter the output to only the commands containing \"git\" Piping is a great way to decompose commands into smaller, single-responsibility commands. Tip When you find commands repeating the same options to determine what items to operate on, consider extracting the options into search command that returns ids and then update the other commands take the list of ids. In .net console apps, you can check piped input using Console . IsInputRedirected and Console . In . Read___ () . Or... use our provided middleware","title":"What is piping?"},{"location":"V3/piped-arguments/#using-the-middleware","text":"First, enable the feature with appRunner . AppendPipedInputToOperandList () . Every command is allowed a single operand list. If one is defined and if piped input is available, it will be appended to this list. If the user provides values for the operand and pipes input, the two sources will be concatenated, with piped input at the end. Tip All output to the console is piped to the next command. Be sure the command does not include additional logging information. Caveat The middleware will currently read all piped input before processing the command. This will require the first command to completely finish before the second command starts so this is not yet suitable for streaming. We hope to resolve this in a future release. If you need streaming, please consider helping us enhance this middleware.","title":"Using the middleware?"},{"location":"V3/response-files/","text":"Response Files # Response files are text files containing arguments that can be replaced by their contents in the command line. Micrsoft uses them in several applications including msbuild and the MIDL compiler . Lets start with an example: public void Interceptor ( string user , string pwd , string url ) { _client . Connect ( user , pwd , url ); } public void Find ( string filter , IConsole console ) { _client . Find ( filter ). ForEach ( i => console . Out . WriteLine ( i . Id )); } public void Migrate ( List < string > ids ) { ids . ForEach ( _client . Migrate ); } This app has 2 commands that would be called like this: Find: --user bob --pwd shhh -url dev.site.com Find isNew Migrate: --user bob --pwd shhh -url dev.site.com Migrate 12 3 44 The credentials could be stored in a file: creds/bobs-creds.rsp # bob's dev creds --user bob --pwd shhhh --url dev.site.com Then the call to Find could be @creds / bobs - creds . rsp Find isNew . The expand - response - files token transformation will replace @creds / bobs - creds . rsp with --user bob --pwd shhhh --url dev.site.com . Rules: The file path must be prefixed with @ Empty lines and lines starting with # are skipped Each line is run through a CommandLineStringSplitter to split arguments while honoring quoted strings Multiple arguments can be specified on a single line Arguments can be specified on multiple lines. Files can have any extension as long as the contents are text. Recipes # There are a number of ways to use response files to improve usability and testiblity of your app. Inter-command communication # Similar to piped arguments , a command could write arguments to a response file for use in another command. As an extra step, the path to the response file could be the piped argument. Resume Session # A long running application could maintain a session file with the last processed key or next key or a list of remaining keys. If the app is cancelled or crashes, the user could start from scratch or select a @session-yyyymmdd.rsp to resume the operation. Fail File # An application can store ids of failed items in failed.txt file that can be used to rerun just the failed items. For example: public void Migrate ([ Option ] string failFilePath , List < string > ids ) { if (! ids . Any ()) { ids = _repo . GetAllIds (); } foreach ( var id in ids ) { try { _client . Migrate ( id ); } catch ( Exception ex ) { Log . Error ( ex ); if ( failFilePath != null ) { File . AppendAllText ( failFilePath , id + Environment . NewLine ); } } } } First run: Migrate --failFilePath failed1.txt to migrate all items and capture failed ids to failed1 . txt Trouble shoot errors and deploy code with bug fixes. Second run: Migrate --failFilePath failed2.txt @failed1.txt to migrate all items in failed1 . txt and capture failed ids to failed2 . txt Rinse and repeat. Testing # Response files can be used like configuration files. You can store them for different testing configurations and share them with your team. This can be more efficient than creating batch scripts because you can change some options or in some cases, reuse the same response file across different commands.","title":"Response Files"},{"location":"V3/response-files/#response-files","text":"Response files are text files containing arguments that can be replaced by their contents in the command line. Micrsoft uses them in several applications including msbuild and the MIDL compiler . Lets start with an example: public void Interceptor ( string user , string pwd , string url ) { _client . Connect ( user , pwd , url ); } public void Find ( string filter , IConsole console ) { _client . Find ( filter ). ForEach ( i => console . Out . WriteLine ( i . Id )); } public void Migrate ( List < string > ids ) { ids . ForEach ( _client . Migrate ); } This app has 2 commands that would be called like this: Find: --user bob --pwd shhh -url dev.site.com Find isNew Migrate: --user bob --pwd shhh -url dev.site.com Migrate 12 3 44 The credentials could be stored in a file: creds/bobs-creds.rsp # bob's dev creds --user bob --pwd shhhh --url dev.site.com Then the call to Find could be @creds / bobs - creds . rsp Find isNew . The expand - response - files token transformation will replace @creds / bobs - creds . rsp with --user bob --pwd shhhh --url dev.site.com . Rules: The file path must be prefixed with @ Empty lines and lines starting with # are skipped Each line is run through a CommandLineStringSplitter to split arguments while honoring quoted strings Multiple arguments can be specified on a single line Arguments can be specified on multiple lines. Files can have any extension as long as the contents are text.","title":"Response Files"},{"location":"V3/response-files/#recipes","text":"There are a number of ways to use response files to improve usability and testiblity of your app.","title":"Recipes"},{"location":"V3/response-files/#inter-command-communication","text":"Similar to piped arguments , a command could write arguments to a response file for use in another command. As an extra step, the path to the response file could be the piped argument.","title":"Inter-command communication"},{"location":"V3/response-files/#resume-session","text":"A long running application could maintain a session file with the last processed key or next key or a list of remaining keys. If the app is cancelled or crashes, the user could start from scratch or select a @session-yyyymmdd.rsp to resume the operation.","title":"Resume Session"},{"location":"V3/response-files/#fail-file","text":"An application can store ids of failed items in failed.txt file that can be used to rerun just the failed items. For example: public void Migrate ([ Option ] string failFilePath , List < string > ids ) { if (! ids . Any ()) { ids = _repo . GetAllIds (); } foreach ( var id in ids ) { try { _client . Migrate ( id ); } catch ( Exception ex ) { Log . Error ( ex ); if ( failFilePath != null ) { File . AppendAllText ( failFilePath , id + Environment . NewLine ); } } } } First run: Migrate --failFilePath failed1.txt to migrate all items and capture failed ids to failed1 . txt Trouble shoot errors and deploy code with bug fixes. Second run: Migrate --failFilePath failed2.txt @failed1.txt to migrate all items in failed1 . txt and capture failed ids to failed2 . txt Rinse and repeat.","title":"Fail File"},{"location":"V3/response-files/#testing","text":"Response files can be used like configuration files. You can store them for different testing configurations and share them with your team. This can be more efficient than creating batch scripts because you can change some options or in some cases, reuse the same response file across different commands.","title":"Testing"},{"location":"V3/v3-changes/","text":"v3 Changes # v3 is a significant rewrite of the CommandDotNet. The framework has remained mostly backward compatible for basic scenarios. Anything beyond basic scenarios will encounter a breaking change. We welcome everyones help in testing the changes, providing usability feedback, bugs, missing documentation, etc. Given the scope of changes, it's likely something is missed in this doc. If you notice something, please create an issue or submit a pull request for the docs. Thank you. What are the changes? # New architecture # The architecture is not based around a middleware pipeline . Arguments terminology # Terminology for arguments has been updated and made more consistent throughout the framework. This article describes how argument is an overloaded term. It can mean all of the words after the name of the application name or just the words that are not commands. We now recognize there are two different contexts with different needs. The user of the console app: needs to understand when arguments are named vs positional. We should strive to use terms they are already familiar with. The developer of the console app: needs to define arguments that are named vs positional. Occasionally the developers need to operate across both types of arguments regardless of the type. We've addressed both. Now, there are two types of arguments; options and operands. And, there are two ways to define them; parameters and properties. Options are always named and Operands are always positional. Pararmeter is no longer an overloaded term for argument. Determining what should be an option vs operand can be confusing. One approach is to consider operands what the command operates on and options inform how the command operates on them, as described in the article from above. For example, In the calculator here , x and y are the operands and --radix informs how the numbers are represented in the operations. The user's interface with the app is the help documentation where we still use the terms command, option and argument. This is the more common terminology in help documentation of existing apps and so the user is likely more familiar with it. We don't expect users to understand what an operand is. Constructor based dependency injection is now possible # read more below Summary of new features # Response file support HelpTextProvider can be overridden to make targetted changes to a section of help. Test tools, helpful for end-to-end test and testing framework extensions, like middleware components. (available soon) List operands can be populated from piped arguments . Parameter resolvers Ctrl+C support with CancellationToken Several bugs were fixed along the way. Breaking Changes # We initially tried to roll out this update in backward compatible phases. Due to the scope of changes, that proved more burdonsome that it was worth. We decided the benefits were worth the price of breaking changes. Hopefully you'll agree... maybe not during the update, but shortly there after. In some cases, i.e. renamed attributes, the old method or class has been marked with [ Obsolete ] and warnings will suggest how to upgrade. These will be removed in the next major release, 4 . x There are a set of changes your IDE should be able to help you with. For example, namespaces were updated to reflect their functional purpose. Your IDE will likely suggest the fixes and then you can remove the old namespaces. AppSettings & Configuration # Fluent validation, prompting for missing arguments and fluent validation are no longer enabled by default. Use these configuration extensions to enable them: UseVersionMiddleware , UsePromptForMissingOperands , and UseFluentValidation Interceptor Methods # Interceptor Methods replace Constructor Options # Constructor-based dependency injection was not possible because of the feature using constructors to define options that can be used for all subcommands defined in that class prevented Those constructors will need to be replaced with interceptor methods. There are two signatures for interceptor methods. Task < int > Inteceptor ( CommandContext ctx , ExecutionDelegate next , ... ) and Task < int > Inteceptor ( InterceptorExecutionDelegate next , ... ) The method name does not matter. What does matter is the Task < int > type and use of either ExecutionDelegate . The former requires a CommandContext . Options can be defined in these methods but are not required. Interceptor Methods scope includes all ancestor commands # Previously with constructor options, when there were multiple levels of subcommands, only the constructor option for the class of the target command was executed. This can lead to a confusing experience where a parent command defines options but they aren't used because a subcommand of a subcommand has been requested. As an example, let's say we have a console app api . exe for an api and the app mimics the RESTful design of the api. The commands are: api . exe - the root app, with a constructor defining the option --url users - command from a nested class list - a method to list the users Usage: api . exe --url api-url users ls This example would not work in v2 because the --url option, defined in the API class would never be called. v3 fixes this by keeping a pipeline of all interceptors. If you need the old behavior, use the following code to keep only the interceptor in the same class as the target command. appRunner . Configure ( c => c . UseMiddleware (( ctx , next ) => { var pipeline = ctx . InvocationPipeline ; pipeline . AncestorInterceptors = pipeline . All . Where ( s => s . Invocation . MethodInfo . DeclaringType == pipeline . TargetCommand . Invocation . MethodInfo . DeclaringType ) . ToList (); return next ( ctx ); }, MiddlewareStages . PostParseInputPreBindValues )); Configuration # Use AppRunner . Configure for any configuration not located in AppSettings. This includes setting a custom help text provider, dependency resolver, etc. CommandInvoker removed # The middleware pipeline architecture obsoleted the CommandInvoker. Look at the CommandInvokerTests in the repo to see how the feature can be implemented using middleware. Where the CommandInvoker only worked for the command method, the new architecture allows interogating all of the interceptor methods too. Remaining work # external dependencies move FluentValidation into a separate nuget package move Humanizer into a separate nuget package update CommandDotNet.Ioc... repos make test tools available via nuget complete features RemainingOperands SeparatedArguments argument arity define it with argument display it in help validate it","title":"v3 Changes"},{"location":"V3/v3-changes/#v3-changes","text":"v3 is a significant rewrite of the CommandDotNet. The framework has remained mostly backward compatible for basic scenarios. Anything beyond basic scenarios will encounter a breaking change. We welcome everyones help in testing the changes, providing usability feedback, bugs, missing documentation, etc. Given the scope of changes, it's likely something is missed in this doc. If you notice something, please create an issue or submit a pull request for the docs. Thank you.","title":"v3 Changes"},{"location":"V3/v3-changes/#what-are-the-changes","text":"","title":"What are the changes?"},{"location":"V3/v3-changes/#new-architecture","text":"The architecture is not based around a middleware pipeline .","title":"New architecture"},{"location":"V3/v3-changes/#arguments-terminology","text":"Terminology for arguments has been updated and made more consistent throughout the framework. This article describes how argument is an overloaded term. It can mean all of the words after the name of the application name or just the words that are not commands. We now recognize there are two different contexts with different needs. The user of the console app: needs to understand when arguments are named vs positional. We should strive to use terms they are already familiar with. The developer of the console app: needs to define arguments that are named vs positional. Occasionally the developers need to operate across both types of arguments regardless of the type. We've addressed both. Now, there are two types of arguments; options and operands. And, there are two ways to define them; parameters and properties. Options are always named and Operands are always positional. Pararmeter is no longer an overloaded term for argument. Determining what should be an option vs operand can be confusing. One approach is to consider operands what the command operates on and options inform how the command operates on them, as described in the article from above. For example, In the calculator here , x and y are the operands and --radix informs how the numbers are represented in the operations. The user's interface with the app is the help documentation where we still use the terms command, option and argument. This is the more common terminology in help documentation of existing apps and so the user is likely more familiar with it. We don't expect users to understand what an operand is.","title":"Arguments terminology"},{"location":"V3/v3-changes/#constructor-based-dependency-injection-is-now-possible","text":"read more below","title":"Constructor based dependency injection is now possible"},{"location":"V3/v3-changes/#summary-of-new-features","text":"Response file support HelpTextProvider can be overridden to make targetted changes to a section of help. Test tools, helpful for end-to-end test and testing framework extensions, like middleware components. (available soon) List operands can be populated from piped arguments . Parameter resolvers Ctrl+C support with CancellationToken Several bugs were fixed along the way.","title":"Summary of new features"},{"location":"V3/v3-changes/#breaking-changes","text":"We initially tried to roll out this update in backward compatible phases. Due to the scope of changes, that proved more burdonsome that it was worth. We decided the benefits were worth the price of breaking changes. Hopefully you'll agree... maybe not during the update, but shortly there after. In some cases, i.e. renamed attributes, the old method or class has been marked with [ Obsolete ] and warnings will suggest how to upgrade. These will be removed in the next major release, 4 . x There are a set of changes your IDE should be able to help you with. For example, namespaces were updated to reflect their functional purpose. Your IDE will likely suggest the fixes and then you can remove the old namespaces.","title":"Breaking Changes"},{"location":"V3/v3-changes/#appsettings-configuration","text":"Fluent validation, prompting for missing arguments and fluent validation are no longer enabled by default. Use these configuration extensions to enable them: UseVersionMiddleware , UsePromptForMissingOperands , and UseFluentValidation","title":"AppSettings &amp; Configuration"},{"location":"V3/v3-changes/#interceptor-methods","text":"","title":"Interceptor Methods"},{"location":"V3/v3-changes/#interceptor-methods-replace-constructor-options","text":"Constructor-based dependency injection was not possible because of the feature using constructors to define options that can be used for all subcommands defined in that class prevented Those constructors will need to be replaced with interceptor methods. There are two signatures for interceptor methods. Task < int > Inteceptor ( CommandContext ctx , ExecutionDelegate next , ... ) and Task < int > Inteceptor ( InterceptorExecutionDelegate next , ... ) The method name does not matter. What does matter is the Task < int > type and use of either ExecutionDelegate . The former requires a CommandContext . Options can be defined in these methods but are not required.","title":"Interceptor Methods replace Constructor Options"},{"location":"V3/v3-changes/#interceptor-methods-scope-includes-all-ancestor-commands","text":"Previously with constructor options, when there were multiple levels of subcommands, only the constructor option for the class of the target command was executed. This can lead to a confusing experience where a parent command defines options but they aren't used because a subcommand of a subcommand has been requested. As an example, let's say we have a console app api . exe for an api and the app mimics the RESTful design of the api. The commands are: api . exe - the root app, with a constructor defining the option --url users - command from a nested class list - a method to list the users Usage: api . exe --url api-url users ls This example would not work in v2 because the --url option, defined in the API class would never be called. v3 fixes this by keeping a pipeline of all interceptors. If you need the old behavior, use the following code to keep only the interceptor in the same class as the target command. appRunner . Configure ( c => c . UseMiddleware (( ctx , next ) => { var pipeline = ctx . InvocationPipeline ; pipeline . AncestorInterceptors = pipeline . All . Where ( s => s . Invocation . MethodInfo . DeclaringType == pipeline . TargetCommand . Invocation . MethodInfo . DeclaringType ) . ToList (); return next ( ctx ); }, MiddlewareStages . PostParseInputPreBindValues ));","title":"Interceptor Methods scope includes all ancestor commands"},{"location":"V3/v3-changes/#configuration","text":"Use AppRunner . Configure for any configuration not located in AppSettings. This includes setting a custom help text provider, dependency resolver, etc.","title":"Configuration"},{"location":"V3/v3-changes/#commandinvoker-removed","text":"The middleware pipeline architecture obsoleted the CommandInvoker. Look at the CommandInvokerTests in the repo to see how the feature can be implemented using middleware. Where the CommandInvoker only worked for the command method, the new architecture allows interogating all of the interceptor methods too.","title":"CommandInvoker removed"},{"location":"V3/v3-changes/#remaining-work","text":"external dependencies move FluentValidation into a separate nuget package move Humanizer into a separate nuget package update CommandDotNet.Ioc... repos make test tools available via nuget complete features RemainingOperands SeparatedArguments argument arity define it with argument display it in help validate it","title":"Remaining work"}]}