{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction # Model your command line application interface in a class The purpose of this framework is to let developers focus on the core logic of command line application and forget about how arguments are parsed & validated . This library also let's you structure your CLI app into a hierarchy of commands and subcommands and invokes appropriate methods in your app based on user input. It provides out of the box CLI help with full customization options. Credits \ud83c\udf89 # Special thanks to Drew Burlingame for continuous support and contributions","title":"Introduction"},{"location":"#introduction","text":"Model your command line application interface in a class The purpose of this framework is to let developers focus on the core logic of command line application and forget about how arguments are parsed & validated . This library also let's you structure your CLI app into a hierarchy of commands and subcommands and invokes appropriate methods in your app based on user input. It provides out of the box CLI help with full customization options.","title":"Introduction"},{"location":"#credits","text":"Special thanks to Drew Burlingame for continuous support and contributions","title":"Credits \ud83c\udf89"},{"location":"argument-models/","text":"[ApplicationMetadata(Name=\"send\", Description=\"sends email\")] public void SendEmail ([ Option ] string subject , [ Option ( ShortName = \"a\" )] List < string > attachments , [ Option ] string body , [ Argument ] string from , [ Argument ] string to ) { } this can be invoked from the shell with: send --subject hi -a \"myFile.txt\" -a \"important.docx\" --body \"just wanted you to review these files\" bilal@bilal.com john@john.com The same arguments can be defined with a class: public class Email : IArgumentModel { [Option] public string Subject { get ; set ;} [Option(ShortName=\"a\")] public List < string > Attachments { get ; set ;} [Option] public string Body { get ; set ;} [Argument] public string From { get ; set ;} [Argument] public string To { get ; set ;} } and [ApplicationMetadata(Name=\"send\", Description=\"sends email\")] public void SendEmail ( Email email ) { } Benefits of argument models: # Common arguments can be extracted to models to enforce contracts across commands. ex. DryRunModel ensures the same short name, long name, description, etc are consistent across all commands using this model. FluentValidation framework can be used to validate the model Caveat # Argument position cannot be guaranteed to be consistent because the .Net Framework does not guarantee the order properties are reflected. The GetProperties method does not return properties in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which properties are returned, because that order varies. Order can differ on each machine the app is deployed to. This is not an issue with Option because options are positional Recommendation # Avoid modelling arguments in argument models unless you need to validate them using FluentValidation. If you do need to model arguments and you have scripts in place, verify the scripts work as expected on each new machine, after .net framework updates and after new deployments.","title":"Argument Models"},{"location":"argument-models/#benefits-of-argument-models","text":"Common arguments can be extracted to models to enforce contracts across commands. ex. DryRunModel ensures the same short name, long name, description, etc are consistent across all commands using this model. FluentValidation framework can be used to validate the model","title":"Benefits of argument models:"},{"location":"argument-models/#caveat","text":"Argument position cannot be guaranteed to be consistent because the .Net Framework does not guarantee the order properties are reflected. The GetProperties method does not return properties in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which properties are returned, because that order varies. Order can differ on each machine the app is deployed to. This is not an issue with Option because options are positional","title":"Caveat"},{"location":"argument-models/#recommendation","text":"Avoid modelling arguments in argument models unless you need to validate them using FluentValidation. If you do need to model arguments and you have scripts in place, verify the scripts work as expected on each new machine, after .net framework updates and after new deployments.","title":"Recommendation"},{"location":"async-methods/","text":"The following types of methods are supported : void int Task Task < int > async Task async Task < int > Task result types will be awaited automatically","title":"Async methods"},{"location":"attributes/","text":"ApplicationMetadata # You can use the [ ApplicationMetadata ] attribute on the class level like this to provide details when application is called with help switch. Example: [ApplicationMetadata(Description = \"This is a crappy calculator\", ExtendedHelpText = \"Some more help text that appears at the bottom\")] public class Calculator { } This attribute can also be used on a Method as shown below. [ApplicationMetadata(Description = \"Subtracts value2 from value1 and prints output\", ExtendedHelpText = \"Again, some more detailed help text which has no meaning I still have to write to demostrate this feature\", Name = \"subtractValues\")] public void Subtract ( int value1 , int value2 ) { } Tip When you use ApplicationMetadata attribute on a method, you can change the name of the command that is different from method name. SubCommand # [ SubCommand ] attribute indicates that targeted property is a SubCommand. See Nesting commands for examples Argument # Every parameter in the method is argument by default. So this this Attribute is optional and should be used only when you need to assign a different name to parameter, or add description to it. By default, the parameter names declared in method are the argument names that appear in help. However you can change that. Let's see an example- public void LaunchRocket ([ Argument ( Name = \"planet\" , Description = \"Name of the planet you wish the rocket to go)] string planetName) This is what help looks like- Usage: dotnet example.dll LaunchRocket [ arguments ] [ options ] Arguments: planetName String Name of the planet you wish the rocket to go Options: -h | -? | --help Show help information Option # Every parameter in the method is argument by default. So if you wan't to turn a parameter into option instead of argument, use this attribute. See more info about parameters here By default, the parameter names declared in method are the option names that appear in help. However you can change that. By convention, an option can have a short name and/or a long name. Let's see an example- public void LaunchRocket ([ Option ( LongName = \"planet\" , ShortName = \"p\" , Description = \"Name of the planet you wish the rocket to go\" )] string planetName ) This is what help looks like- Usage: dotnet example.dll LaunchRocket [ options ] Options: -h | -? | --help Show help information --planet | -p String Name of the planet you wish the rocket to go So planet name can now be passed either with --planet or - p . LongName, ShortName and Description are optional. When you don't specify a long name and a short name for an option, it uses the method parameter name by default as long name. In case the method parameter name is just one letter, it will be treated as short name. Here's table of examples: Method parameter name Longname Shortname Generated template planet --planet planet planet --planet planet p - p planet planet p - p | --planet p - p","title":"Attributes"},{"location":"attributes/#applicationmetadata","text":"You can use the [ ApplicationMetadata ] attribute on the class level like this to provide details when application is called with help switch. Example: [ApplicationMetadata(Description = \"This is a crappy calculator\", ExtendedHelpText = \"Some more help text that appears at the bottom\")] public class Calculator { } This attribute can also be used on a Method as shown below. [ApplicationMetadata(Description = \"Subtracts value2 from value1 and prints output\", ExtendedHelpText = \"Again, some more detailed help text which has no meaning I still have to write to demostrate this feature\", Name = \"subtractValues\")] public void Subtract ( int value1 , int value2 ) { } Tip When you use ApplicationMetadata attribute on a method, you can change the name of the command that is different from method name.","title":"ApplicationMetadata"},{"location":"attributes/#subcommand","text":"[ SubCommand ] attribute indicates that targeted property is a SubCommand. See Nesting commands for examples","title":"SubCommand"},{"location":"attributes/#argument","text":"Every parameter in the method is argument by default. So this this Attribute is optional and should be used only when you need to assign a different name to parameter, or add description to it. By default, the parameter names declared in method are the argument names that appear in help. However you can change that. Let's see an example- public void LaunchRocket ([ Argument ( Name = \"planet\" , Description = \"Name of the planet you wish the rocket to go)] string planetName) This is what help looks like- Usage: dotnet example.dll LaunchRocket [ arguments ] [ options ] Arguments: planetName String Name of the planet you wish the rocket to go Options: -h | -? | --help Show help information","title":"Argument"},{"location":"attributes/#option","text":"Every parameter in the method is argument by default. So if you wan't to turn a parameter into option instead of argument, use this attribute. See more info about parameters here By default, the parameter names declared in method are the option names that appear in help. However you can change that. By convention, an option can have a short name and/or a long name. Let's see an example- public void LaunchRocket ([ Option ( LongName = \"planet\" , ShortName = \"p\" , Description = \"Name of the planet you wish the rocket to go\" )] string planetName ) This is what help looks like- Usage: dotnet example.dll LaunchRocket [ options ] Options: -h | -? | --help Show help information --planet | -p String Name of the planet you wish the rocket to go So planet name can now be passed either with --planet or - p . LongName, ShortName and Description are optional. When you don't specify a long name and a short name for an option, it uses the method parameter name by default as long name. In case the method parameter name is just one letter, it will be treated as short name. Here's table of examples: Method parameter name Longname Shortname Generated template planet --planet planet planet --planet planet p - p planet planet p - p | --planet p - p","title":"Option"},{"location":"collections/","text":"Let's enhance our rocket launcher to support multiple planets. Collection of Options # public void LaunchRocket ([ Option ( ShortName = \"p\" )] List < string > planets ) This is what help information looks like- INPUT dotnet example.dll LaunchRocket --help OUTPUT Usage: dotnet example.dll LaunchRocket [ options ] Options: -h | -? | --help Show help information -p String ( Multiple ) And this is how you pass multiple options: dotnet example.dll LaunchRocket -p mars -p earth -p jupiter Collection of Arguments # public void LaunchRocket ( List < string > planets ) INPUT dotnet example.dll LaunchRocket --help OUTPUT Usage: dotnet example.dll LaunchRocket [ arguments ] [ options ] Arguments: planets String ( Multiple ) Options: -h | -? | --help Show help information And this is how you pass multiple arguments: dotnet example.dll LaunchRocket mars earth jupiter","title":"Collections"},{"location":"collections/#collection-of-options","text":"public void LaunchRocket ([ Option ( ShortName = \"p\" )] List < string > planets ) This is what help information looks like- INPUT dotnet example.dll LaunchRocket --help OUTPUT Usage: dotnet example.dll LaunchRocket [ options ] Options: -h | -? | --help Show help information -p String ( Multiple ) And this is how you pass multiple options: dotnet example.dll LaunchRocket -p mars -p earth -p jupiter","title":"Collection of Options"},{"location":"collections/#collection-of-arguments","text":"public void LaunchRocket ( List < string > planets ) INPUT dotnet example.dll LaunchRocket --help OUTPUT Usage: dotnet example.dll LaunchRocket [ arguments ] [ options ] Arguments: planets String ( Multiple ) Options: -h | -? | --help Show help information And this is how you pass multiple arguments: dotnet example.dll LaunchRocket mars earth jupiter","title":"Collection of Arguments"},{"location":"constructors/","text":"Let's say we want to add a class level field which is useful in both Addition and Subtraction. So now the class looks something like this- public class Calculator { private readonly bool _printValues ; public Calculator ( bool printValues ) { _printValues = printValues ; } [ApplicationMetadata(Description = \"Adds two numbers. duh!\")] public void Add ( int value1 , int value2 ) { if ( _printValues ) { Console . WriteLine ( $ \"value1 : {value1}, value2: {value2}\" ); } Console . WriteLine ( $ \"Answer: {value1 + value2}\" ); } public void Subtract ( int value1 , int value2 ) { if ( _printValues ) { Console . WriteLine ( $ \"value1 : {value1}, value2: {value2}\" ); } Console . WriteLine ( $ \"Answer: {value1 - value2}\" ); } } Let's see what the help command output looks like now INPUT dotnet example.dll --help OUTPUT Usage: dotnet example.dll [ options ] [ command ] Options: -h | -? | --help Show help information --printValues Flag Commands: Add Adds two numbers. duh! Subtract Use \"dotnet example.dll [command] --help\" for more information about a command. Let's try and invoke it INPUT dotnet example.dll --printValues Subtract 30 5 OUTPUT value1 : 30 , value2: 5 Answer: 25 Notes: You can skip to pass any parameter. It will then fallback to the default value of parameter type Any parameters in constructor are Options by default and you can't have Argument attribute in constructor parameters Only one constructor is supported. If there are multiple, it will pick up first defined constructor Inherited # [ Options ] attribute has a property called Inherited . This is particularly useful when used with constructor options. When set to true, that option is can be passed to commands as well.","title":"Constructors"},{"location":"constructors/#inherited","text":"[ Options ] attribute has a property called Inherited . This is particularly useful when used with constructor options. When set to true, that option is can be passed to commands as well.","title":"Inherited"},{"location":"custom-interceptors/","text":"Custom interceptors before method execution # Invoking the command method can be customized by implementing ICommandInvoker and registering the an instance with AppRunner.WithCommandInvoker. The WithCommandInvoker method provides the default implementation so it can be wrapped using the Decorator Pattern . static int Main ( string [] args ) { AppRunner < CustomCommandInvokerApp > appRunner = new AppRunner < CustomCommandInvokerApp >(). WithCommandInvoker ( inner => new CustomCommandInvoker ( inner )); return appRunner . Run ( args ); } public class CustomCommandInvoker : ICommandInvoker { private readonly ICommandInvoker _inner ; public CustomCommandInvoker ( ICommandInvoker inner ) { _inner = inner ; } public object Invoke ( CommandInvocation commandInvocation ) { // Your custom code here return _inner . Invoke ( commandInvocation ); } }","title":"Custom interceptors"},{"location":"custom-interceptors/#custom-interceptors-before-method-execution","text":"Invoking the command method can be customized by implementing ICommandInvoker and registering the an instance with AppRunner.WithCommandInvoker. The WithCommandInvoker method provides the default implementation so it can be wrapped using the Decorator Pattern . static int Main ( string [] args ) { AppRunner < CustomCommandInvokerApp > appRunner = new AppRunner < CustomCommandInvokerApp >(). WithCommandInvoker ( inner => new CustomCommandInvoker ( inner )); return appRunner . Run ( args ); } public class CustomCommandInvoker : ICommandInvoker { private readonly ICommandInvoker _inner ; public CustomCommandInvoker ( ICommandInvoker inner ) { _inner = inner ; } public object Invoke ( CommandInvocation commandInvocation ) { // Your custom code here return _inner . Invoke ( commandInvocation ); } }","title":"Custom interceptors before method execution"},{"location":"custom-return-codes/","text":"Typically when a console app exits with no erros, it returns 0 exit code. If there there was an error, it return 1 . But there are many possiblities and developers use this exit code to convey details about what exactly happenned. For example, https://msdn.microsoft.com/en-us/library/ms681381.aspx When you write a command line application you can return a custom return code. I added a new method in my Calculator to accept a number as input and exit the application with that number as exit code. [ApplicationMetadata(Description = \"Return with code 5\", Name = \"return\")] public int ReturnCode () { return 5 ; } So now when I call this method from console dotnet example . dll return , the command ends with an exit code of 5. Important Main method's return type should be int for this to work","title":"Custom return codes"},{"location":"default-method/","text":"Right now, when you just execute the dll, without any commands, it shows help. If you want to call a method when application is executed without any commands, you can do that with the help of [ DefaultMethod ] attribute. [DefaultMethod] public void SomeMethod () { } Some points to note about default method: It won't show up in help and can't be called explicitly with method name. The only way to execute it is not passing any command name It does not support any parameters It can have access to class level fields which are passed via constructor","title":"Default method"},{"location":"default-values/","text":"C# supports default values for parameters and so does this library. Let's make some changes to Calculator to add a new Command - Divide . And let's default value2 to 1 when user doesn't provide a value. This will prevent the calculator from crashing because of DivideByZeroException public void Divide ( int value1 , int value2 = 1 ) { Console . WriteLine ( $ \"Answer: {value1 / value2}\" ); } Here's how help looks like: INPUT dotnet example.dll Divide --help OUTPUT Usage: dotnet example.dll Divide [ arguments ] [ options ] Arguments: value1 Int32 value2 Int32 | Default value: 1 Options: -h | -? | --help Show help information","title":"Default values"},{"location":"dependency-injection/","text":"Let's say your app uses a service : public interface IService { int GetValue (); } public class Service : IService { public int GetValue () { return 4 ; } } Without dependency injection, app will have to create an instance of Service manually: public class App { public void PrintServiceValue () { IService service = new Service (); Console . WriteLine ( service . GetValue (). ToString ()); } } This looks simple now but because the Service class constructor doesn't have any constructor parameters but if it had, it would have been difficult for App to create the instance of Service . Another reason why you might want to use dependency injection is testable code. This is how App looks like with \"Property injection\" public class App { [InjectProperty] public IService Service { get ; set ;} public void PrintServiceValue () { Console . WriteLine ( Service . GetValue (). ToString ()); } } The benefit here is that you can mock IService and just test the behavior of App without worrying about Service class. CommandDotNet supports two IoC frameworks - Autofac & Microsoft Autofac # In order to use autofac, you need to install an additional integration nuget package : https://www.nuget.org/packages/CommandDotNet.IoC.Autofac/ This how you can use the package: static int Main ( string [] args ) { ContainerBuilder containerBuilder = new ContainerBuilder (); containerBuilder . RegisterType < Service >(). As < IService >(); IContainer container = containerBuilder . Build (); AppRunner < ServiceApp > appRunner = new AppRunner < ServiceApp >(). UseAutofac ( container ); return appRunner . Run ( args ); } Microsoft # In order to use Microsoft Dependency Injection, you need to install an additional integration nuget package : https://www.nuget.org/packages/CommandDotNet.IoC.MicrosoftDependencyInjection/ This how you can use the package: static int Main ( string [] args ) { IServiceCollection serviceCollection = new ServiceCollection (); serviceCollection . AddSingleton < IService , Service >(); IServiceProvider serviceProvider = serviceCollection . BuildServiceProvider (); AppRunner < ServiceApp > appRunner = new AppRunner < ServiceApp >(). UseMicrosoftDependencyInjection ( serviceProvider ) return appRunner . Run ( args ); }","title":"Dependency Injection"},{"location":"dependency-injection/#autofac","text":"In order to use autofac, you need to install an additional integration nuget package : https://www.nuget.org/packages/CommandDotNet.IoC.Autofac/ This how you can use the package: static int Main ( string [] args ) { ContainerBuilder containerBuilder = new ContainerBuilder (); containerBuilder . RegisterType < Service >(). As < IService >(); IContainer container = containerBuilder . Build (); AppRunner < ServiceApp > appRunner = new AppRunner < ServiceApp >(). UseAutofac ( container ); return appRunner . Run ( args ); }","title":"Autofac"},{"location":"dependency-injection/#microsoft","text":"In order to use Microsoft Dependency Injection, you need to install an additional integration nuget package : https://www.nuget.org/packages/CommandDotNet.IoC.MicrosoftDependencyInjection/ This how you can use the package: static int Main ( string [] args ) { IServiceCollection serviceCollection = new ServiceCollection (); serviceCollection . AddSingleton < IService , Service >(); IServiceProvider serviceProvider = serviceCollection . BuildServiceProvider (); AppRunner < ServiceApp > appRunner = new AppRunner < ServiceApp >(). UseMicrosoftDependencyInjection ( serviceProvider ) return appRunner . Run ( args ); }","title":"Microsoft"},{"location":"directives/","text":"Directives # Directives are special arguments enabling cross cutting features. We've followed the pattern defined by System.CommandLine to provide two directives: Debug & Parse new AppSettings { EnableDirectives = true } Directives must be the first argument and will be removed from further processing. Debug # Sometimes you just need to debug into a process and configuring the debug arguments in VS is too many extra steps. When you specify [ debug ] , the process id will output to the console and wait for you to attach a debugger. Attach your debugger to process 24236 ({ exe name }) . Parse # Rules for including spaces in arguments and escaping special characters differ from shell to shell. Sometimes it's not clear why arguments are not mapping correctly. When you specify [ parse ] , the process will exit immediately after printing each argument onto a new line. This enables you to catch cases where the shell did not parse your arguments as expected. Use [ parse : verbose ] to see changes after each TokenTransformation (expand-response-files, expand-clubbed-flags, split-option-assignments) to pinpoint which transformation resulted in unexpected changes.","title":"Directives"},{"location":"directives/#directives","text":"Directives are special arguments enabling cross cutting features. We've followed the pattern defined by System.CommandLine to provide two directives: Debug & Parse new AppSettings { EnableDirectives = true } Directives must be the first argument and will be removed from further processing.","title":"Directives"},{"location":"directives/#debug","text":"Sometimes you just need to debug into a process and configuring the debug arguments in VS is too many extra steps. When you specify [ debug ] , the process id will output to the console and wait for you to attach a debugger. Attach your debugger to process 24236 ({ exe name }) .","title":"Debug"},{"location":"directives/#parse","text":"Rules for including spaces in arguments and escaping special characters differ from shell to shell. Sometimes it's not clear why arguments are not mapping correctly. When you specify [ parse ] , the process will exit immediately after printing each argument onto a new line. This enables you to catch cases where the shell did not parse your arguments as expected. Use [ parse : verbose ] to see changes after each TokenTransformation (expand-response-files, expand-clubbed-flags, split-option-assignments) to pinpoint which transformation resulted in unexpected changes.","title":"Parse"},{"location":"exceptions/","text":"Any exception that is thrown from the method or constructor is thrown as is. You can catch it over the AppRunner < T > . Run () method otherwise exception will be unhandled and application will crash. try { AppRunner < Calculator > appRunner = new AppRunner < Calculator >(); return appRunner . Run ( args ); } catch ( MyBusinessException ex ) { Console . WriteLine ( ex . Message ); }","title":"Exceptions"},{"location":"fluent-validation-for-argument-models/","text":"You can use FluentValidation with this library to validate argument models . Here's an example, class Program { static int Main ( string [] args ) { AppRunner < ValidationApp > appRunner = new AppRunner < ValidationApp >(); return appRunner . Run ( args ); } } public class ValidationApp { public void ValidateModel ( PersonModel person ) { string content = JsonConvert . SerializeObject ( person , Formatting . Indented ); Console . WriteLine ( content ); } } [Validator(typeof(PersonValidator))] public class PersonModel : IArgumentModel { public int Id { get ; set ; } public string Name { get ; set ; } public string Email { get ; set ; } } public class PersonValidator : AbstractValidator < PersonModel > { public PersonValidator () { RuleFor ( x => x . Id ). GreaterThan ( 0 ); RuleFor ( x => x . Name ). NotEmpty (); RuleFor ( x => x . Email ). NotEmpty (). EmailAddress (); } } If the validation fails, app exits with return code 2 and prints validation error messages on screen.","title":"Fluent validation for parameters"},{"location":"nesting-commands/","text":"You can nest commands. Let's take git for example git has a command called stash. When you execute git stash , it stashes all the changes. But stash has further commands like, git stash pop , git stash list , etc. Let's try and mimic the same behavior using CommandDotNet: [ApplicationMetadata(Description = \"Fake git application\")] public class Git { [ApplicationMetadata(Description = \"Commits all staged changes\")] public void Commit ([ Option ( ShortName = \"m\" )] string commitMessage ) { Console . WriteLine ( \"Commit successful\" ); } [ApplicationMetadata(Description = \"Stashes all changes when executed without any arguments\")] [SubCommand] public class Stash { [DefaultMethod] public void StashDefaultCommand () { Console . WriteLine ( $ \"changes stashed\" ); } [ApplicationMetadata(Description = \"Applies last stashed changes\")] public void Pop () { Console . WriteLine ( $ \"stash popped\" ); } [ApplicationMetadata(Description = \"Lists all stashed changes\")] public void List () { Console . WriteLine ( $ \"here's the list of stash\" ); } } } Here's how the help looks like now: Fake git application Usage: dotnet example.dll [ options ] [ command ] Options: -h | -? | --help Show help information Commands: Commit Commits all staged changes Stash Stashes all changes when executed without any arguments Use \"dotnet example.dll [command] --help\" for more information about a command. Here's how the interaction looks like: INPUT dotnet example.dll commit -m \"some refactoring\" OUTPUT Commit successful INPUT dotnet example.dll stash OUTPUT changes stashed INPUT dotnet example.dll stash --help OUTPUT Stashes all changes when executed without any arguments Usage: dotnet example.dll Stash [ options ] [ command ] Options: -h | -? | --help Show help information Commands: List Lists all saved stashed changes Pop Applies last stashed changes Use \"Stash [command] --help\" for more information about a command. INPUT dotnet example.dll stash pop OUTPUT stash popped Alternative If you like to store your sub commands as external .cs files, you can that too with [ SubCommand ] attribute. [ApplicationMetadata(Description = \"Stashes all changes when executed without any arguments\")] public class Stash { [ApplicationMetadata(Description = \"Applies last stashed changes\")] public void Pop () { Console . WriteLine ( $ \"stash popped\" ); } } [ApplicationMetadata(Description = \"Fake git application\")] public class Git { [SubCommand] public Stash Stash { get ; set ;} // Stash class is saved in a seperate file [ApplicationMetadata(Description = \"Commits all staged changes\")] public void Commit ([ Option ( ShortName = \"m\" )] string commitMessage ) { Console . WriteLine ( \"Commit successful\" ); } }","title":"Nesting commands"},{"location":"parameter-types/","text":"Supports all types with a string constructor or where a TypeConverter is defined that can convert from a string. Includes, but not limited to: string char bool enum short int long decimal double Guid Uri FileInfo DirectoryInfo Also supports List < T > , IEnumerable < T > and Nullable < T > where T can be converted from string. Note: T [] is not currently supported. These are applicable for both - Options and Arguments Note for arguments: - There can be only one List argument in the method. It can be used with other non List type arguments or List type options. - If the method has a List type argument, it should be defined last in the order. Adding support for new types # In most cases, create a TypeConverter for your type If you need to override an existing TypeConverter conditional logic based on argument metadata (custom attributes, etc) the converter only for parsing parameters and not the business logic of your application Implement ITypedArgumentTypeDescriptor or IGenericArgumentTypeDescriptor and register with AppSettings . ArgumentTypeDescriptors . Register (...) .","title":"Parameter types"},{"location":"parameter-types/#adding-support-for-new-types","text":"In most cases, create a TypeConverter for your type If you need to override an existing TypeConverter conditional logic based on argument metadata (custom attributes, etc) the converter only for parsing parameters and not the business logic of your application Implement ITypedArgumentTypeDescriptor or IGenericArgumentTypeDescriptor and register with AppSettings . ArgumentTypeDescriptors . Register (...) .","title":"Adding support for new types"},{"location":"parameters/","text":"Arguments # Arguments are simple as we saw already in the introduction . Arguments are the main parameters of the command and should be as less as possible. If you compare them to a english statement, argument is the Subject of the sentence. Let try an example of an english sentence Please delete sample . docx file Now let's try and remove some extra words we don't need and convert it into command that system can understand. Let's say our command name is delete and its job is to delete files. We don't need the words please and file So we are left with delete sample . docx delete here is the name of command and sample.docx is the subject and hence the argument. C# method for the same would look like public void Delete ( string fileName ) We can have multiple subjects for instance, please delete sample . docx and number . xls . That would turn into delete sample . docx number . xls C# method for the same would look like public void Delete ( List < string > fileNames ) Options # Options are arguments that : - Are optional - Are named - May change behavior of command For instance let's just go with out example from arguments section. This time, the sentence is please delete the file sample . docx tomorrow . In this case, we have extra information about the operation we want to perform i.e. time The command is still delete , the subject(argument) is still sample . docx but the time has changed from now to tomorrow Let's see how we can translate into a cli command delete sample . docx --time tomorrow C# method for the same would look like public void Delete ( string fileName , [ Option ] string time = \"Now\" ) Flags # Flags are very similar to options except for the fact they are aways boolean (& false by default) and don't need an explicit value. If a flag is present, its true, otherwise it's false. Let's continue with same example as options , This time the sentence is Please delete the file sample . docx safely tomorrow . Safely here means that delete it only if no process is using it. It's naturally translated to a cli command as delete sample . docs --safely --time=tomorrow Tip Note that --time tomorrow , --time=tomorrow & --time:tomorrow are the same. Notice that we din't pass any value for --safely option. This is flag and it's value will be true since we have passed it. C# method for the same would look like public void Delete ( string fileName , [Option] bool safely , [Option] string time = \"Now\" )","title":"Parameters"},{"location":"parameters/#arguments","text":"Arguments are simple as we saw already in the introduction . Arguments are the main parameters of the command and should be as less as possible. If you compare them to a english statement, argument is the Subject of the sentence. Let try an example of an english sentence Please delete sample . docx file Now let's try and remove some extra words we don't need and convert it into command that system can understand. Let's say our command name is delete and its job is to delete files. We don't need the words please and file So we are left with delete sample . docx delete here is the name of command and sample.docx is the subject and hence the argument. C# method for the same would look like public void Delete ( string fileName ) We can have multiple subjects for instance, please delete sample . docx and number . xls . That would turn into delete sample . docx number . xls C# method for the same would look like public void Delete ( List < string > fileNames )","title":"Arguments"},{"location":"parameters/#options","text":"Options are arguments that : - Are optional - Are named - May change behavior of command For instance let's just go with out example from arguments section. This time, the sentence is please delete the file sample . docx tomorrow . In this case, we have extra information about the operation we want to perform i.e. time The command is still delete , the subject(argument) is still sample . docx but the time has changed from now to tomorrow Let's see how we can translate into a cli command delete sample . docx --time tomorrow C# method for the same would look like public void Delete ( string fileName , [ Option ] string time = \"Now\" )","title":"Options"},{"location":"parameters/#flags","text":"Flags are very similar to options except for the fact they are aways boolean (& false by default) and don't need an explicit value. If a flag is present, its true, otherwise it's false. Let's continue with same example as options , This time the sentence is Please delete the file sample . docx safely tomorrow . Safely here means that delete it only if no process is using it. It's naturally translated to a cli command as delete sample . docs --safely --time=tomorrow Tip Note that --time tomorrow , --time=tomorrow & --time:tomorrow are the same. Notice that we din't pass any value for --safely option. This is flag and it's value will be true since we have passed it. C# method for the same would look like public void Delete ( string fileName , [Option] bool safely , [Option] string time = \"Now\" )","title":"Flags"},{"location":"quick-start/","text":"Installation # CommandDotNet can be installed from nuget.org .NET CLI dotnet add package CommandDotNet Nuget Package Manager Install-Package CommandDotNet Let's build a calculator # Let's say you want to create a calculator console application which can perform 2 operations: Addition Subtraction It prints the results on console. Let's begin with creating the class public class Calculator { public void Add ( int value1 , int value2 ) { Console . WriteLine ( $ \"Answer: {value1 + value2}\" ); } public void Subtract ( int value1 , int value2 ) { Console . WriteLine ( $ \"Answer: {value1 - value2}\" ); } } Now that we have our calculator ready, let's see about how we can call it from command line. class Program { static int Main ( string [] args ) { AppRunner < Calculator > appRunner = new AppRunner < Calculator >(); return appRunner . Run ( args ); } } Assuming our application's name is example . dll let's try and run this app from command line using dotnet INPUT dotnet example.dll --help OUTPUT Usage: dotnet example.dll [ options ] [ command ] Options: -h | -? | --help Show help information Commands: Add Subtract Use \"dotnet example.dll [command] --help\" for more information about a command. Voila! So, as you might have already guessed, it is detecting methods of the calculator class. How about adding some helpful description. [ApplicationMetadata(Description = \"Adds two numbers. duh!\")] public void Add ( int value1 , int value2 ) { Console . WriteLine ( $ \"Answer: {value1 + value2}\" ); } This should do it. Let's see how the help appears now. Usage: dotnet example.dll [ options ] [ command ] Options: -h | -? | --help Show help information Commands: Add Adds two numbers. duh! Subtract Use \"dotnet example.dll [command] --help\" for more information about a command. Awesome. Descriptions are not required but can be very useful depending upon the complexity of your app and the audience. Now let's try to see if we can get further help for the add command. INPUT dotnet example.dll Add --help OUTPUT Usage: dotnet example.dll Add [ arguments ] [ options ] Arguments: value1 Int32 value2 Int32 Options: -h | -? | --help Show help information tada! Ok, so here, it show what parameters are required for addition and their type. Let's try and add two numbers. INPUT dotnet example.dll Add 40 20 OUTPUT Answer: 60 Cool. You get the gist of this library. Let's move on.","title":"Quick Start"},{"location":"quick-start/#installation","text":"CommandDotNet can be installed from nuget.org .NET CLI dotnet add package CommandDotNet Nuget Package Manager Install-Package CommandDotNet","title":"Installation"},{"location":"quick-start/#lets-build-a-calculator","text":"Let's say you want to create a calculator console application which can perform 2 operations: Addition Subtraction It prints the results on console. Let's begin with creating the class public class Calculator { public void Add ( int value1 , int value2 ) { Console . WriteLine ( $ \"Answer: {value1 + value2}\" ); } public void Subtract ( int value1 , int value2 ) { Console . WriteLine ( $ \"Answer: {value1 - value2}\" ); } } Now that we have our calculator ready, let's see about how we can call it from command line. class Program { static int Main ( string [] args ) { AppRunner < Calculator > appRunner = new AppRunner < Calculator >(); return appRunner . Run ( args ); } } Assuming our application's name is example . dll let's try and run this app from command line using dotnet INPUT dotnet example.dll --help OUTPUT Usage: dotnet example.dll [ options ] [ command ] Options: -h | -? | --help Show help information Commands: Add Subtract Use \"dotnet example.dll [command] --help\" for more information about a command. Voila! So, as you might have already guessed, it is detecting methods of the calculator class. How about adding some helpful description. [ApplicationMetadata(Description = \"Adds two numbers. duh!\")] public void Add ( int value1 , int value2 ) { Console . WriteLine ( $ \"Answer: {value1 + value2}\" ); } This should do it. Let's see how the help appears now. Usage: dotnet example.dll [ options ] [ command ] Options: -h | -? | --help Show help information Commands: Add Adds two numbers. duh! Subtract Use \"dotnet example.dll [command] --help\" for more information about a command. Awesome. Descriptions are not required but can be very useful depending upon the complexity of your app and the audience. Now let's try to see if we can get further help for the add command. INPUT dotnet example.dll Add --help OUTPUT Usage: dotnet example.dll Add [ arguments ] [ options ] Arguments: value1 Int32 value2 Int32 Options: -h | -? | --help Show help information tada! Ok, so here, it show what parameters are required for addition and their type. Let's try and add two numbers. INPUT dotnet example.dll Add 40 20 OUTPUT Answer: 60 Cool. You get the gist of this library. Let's move on.","title":"Let's build a calculator"},{"location":"settings/","text":"When you create a new instance of AppRunner < T > you can pass an instance new AppSettings object. Here are the settings you can change: Show argument details # Shows type information of arguments in help text. Enabled by default. Method argument mode # Possible values : Parameter (default) Option When method argument mode is set to parameter, all arguments of methods are treated as parameters and don't need any names to be passed through command line. Caution Order of passing parameters matter in this mode When method argument mode is set to option, all arguments of methods are treated as options and need a name to be passed. Important This is only applicable for methods and not constructors. For constructors, all arguments are options only Enable version option # True by default. It adds an additional option to the root command. It shows version of the application. Case # public class SomeClass { public SomeClass ( string Url ) { } public void ProcessRequest () { } } by default this would result into something like this: Usage: dotnet example.dll [ options ] [ command ] Options: -h | -? | --help Show help information --Url String Commands: ProcessRequest Use \"dotnet example.dll [command] --help\" for more information about a command. Command line conventions are different from C# conventions and the usual pascal casing of method names or camel casing of parameter names may not be suitable for command line arguments. You can continue to develop you classes and method in normal C# conventions and tell library to transform them into the desired casing. There are 5 modes available: DontChange LowerCase CamelCase KebabCase PascalCase If you now use a different setting, class Program { static int Main ( string [] args ) { AppRunner < SomeClass > appRunner = new AppRunner < SomeClass >( new AppSettings { Case = Case . KebabCase }); return appRunner . Run ( args ); } } The result would something like this: Usage: dotnet example.dll [ options ] [ command ] Options: -h | -? | --help Show help information --url String Commands: process-request Use \"dotnet example.dll [command] --help\" for more information about a command. Note This would not transform any name that you have overridden via [ ApplicationMetadata ] , [ Option ] or [ Argument ] attributes. Boolean mode # In this library, there are two ways to parse boolean Options Note Boolean mod is applicable only for Options and not for Arguments 1. Implicit # This is the default mode. In this mode, you don't pass the value true or false in the command line. These parameters are treated as flags. They are considered true if they are present and false when they are not. For example: dotnet example.dll --printValues In this case, value of parameter printValues will be true and in the following example, dotnet example.dll value of parameter printValues will be false. Note When using implicit boolean mode, it will result in an error, if the user tries to explicitly enter a value for parameter. In this instance, dotnet example . dll --printValues true will result into an error. When you check the help of a command, you if you see Flag for a parameter, it means value is implit and does not require an explicit one. Flag clubbing # Clubbing of one letter options is supported. For example, If a command has multiple boolean flags options like: public void Print ([ Option ( ShortName = \"c\" )] bool qwerty , bool e , bool x ){ } These can be passed either as dotnet example.dll print -c -e -x OR dotnet example.dll print -ecx 2. Explicit # If you want users to explicitly enter true or false, you need to set the boolean mode explicit. You can do that, by using the [ Argument ] attribute as shown below: public void MyCommand ([ Argument ( BooleanMode = BooleanMode . Explicit )] bool capturelogs ) { } Note You can set BooleanMode = BooleanMode . Implicit or BooleanMode = BooleanMode . Explicit only for bool or bool ? type options. When you use explicit boolean mode, these scenarios are valid: dotnet example.dll MyCommand dotnet example.dll MyCommand --capturelogs false dotnet example.dll MyCommand --capturelogs true but dotnet example . dll MyCommand --capturelogs is not valid and will result into error. It will only work in Implicit boolean mode. When you check the help of a command, and you see Boolean it means if you wan't to make it true, you need to pass an explicit value. If you don't pass one, it will default to false automatically. Implicit and explicit are just ways to pass the value, under the hood they are just boolean parameters.","title":"Settings"},{"location":"settings/#show-argument-details","text":"Shows type information of arguments in help text. Enabled by default.","title":"Show argument details"},{"location":"settings/#method-argument-mode","text":"Possible values : Parameter (default) Option When method argument mode is set to parameter, all arguments of methods are treated as parameters and don't need any names to be passed through command line. Caution Order of passing parameters matter in this mode When method argument mode is set to option, all arguments of methods are treated as options and need a name to be passed. Important This is only applicable for methods and not constructors. For constructors, all arguments are options only","title":"Method argument mode"},{"location":"settings/#enable-version-option","text":"True by default. It adds an additional option to the root command. It shows version of the application.","title":"Enable version option"},{"location":"settings/#case","text":"public class SomeClass { public SomeClass ( string Url ) { } public void ProcessRequest () { } } by default this would result into something like this: Usage: dotnet example.dll [ options ] [ command ] Options: -h | -? | --help Show help information --Url String Commands: ProcessRequest Use \"dotnet example.dll [command] --help\" for more information about a command. Command line conventions are different from C# conventions and the usual pascal casing of method names or camel casing of parameter names may not be suitable for command line arguments. You can continue to develop you classes and method in normal C# conventions and tell library to transform them into the desired casing. There are 5 modes available: DontChange LowerCase CamelCase KebabCase PascalCase If you now use a different setting, class Program { static int Main ( string [] args ) { AppRunner < SomeClass > appRunner = new AppRunner < SomeClass >( new AppSettings { Case = Case . KebabCase }); return appRunner . Run ( args ); } } The result would something like this: Usage: dotnet example.dll [ options ] [ command ] Options: -h | -? | --help Show help information --url String Commands: process-request Use \"dotnet example.dll [command] --help\" for more information about a command. Note This would not transform any name that you have overridden via [ ApplicationMetadata ] , [ Option ] or [ Argument ] attributes.","title":"Case"},{"location":"settings/#boolean-mode","text":"In this library, there are two ways to parse boolean Options Note Boolean mod is applicable only for Options and not for Arguments","title":"Boolean mode"},{"location":"settings/#1-implicit","text":"This is the default mode. In this mode, you don't pass the value true or false in the command line. These parameters are treated as flags. They are considered true if they are present and false when they are not. For example: dotnet example.dll --printValues In this case, value of parameter printValues will be true and in the following example, dotnet example.dll value of parameter printValues will be false. Note When using implicit boolean mode, it will result in an error, if the user tries to explicitly enter a value for parameter. In this instance, dotnet example . dll --printValues true will result into an error. When you check the help of a command, you if you see Flag for a parameter, it means value is implit and does not require an explicit one.","title":"1.  Implicit"},{"location":"settings/#flag-clubbing","text":"Clubbing of one letter options is supported. For example, If a command has multiple boolean flags options like: public void Print ([ Option ( ShortName = \"c\" )] bool qwerty , bool e , bool x ){ } These can be passed either as dotnet example.dll print -c -e -x OR dotnet example.dll print -ecx","title":"Flag clubbing"},{"location":"settings/#2-explicit","text":"If you want users to explicitly enter true or false, you need to set the boolean mode explicit. You can do that, by using the [ Argument ] attribute as shown below: public void MyCommand ([ Argument ( BooleanMode = BooleanMode . Explicit )] bool capturelogs ) { } Note You can set BooleanMode = BooleanMode . Implicit or BooleanMode = BooleanMode . Explicit only for bool or bool ? type options. When you use explicit boolean mode, these scenarios are valid: dotnet example.dll MyCommand dotnet example.dll MyCommand --capturelogs false dotnet example.dll MyCommand --capturelogs true but dotnet example . dll MyCommand --capturelogs is not valid and will result into error. It will only work in Implicit boolean mode. When you check the help of a command, and you see Boolean it means if you wan't to make it true, you need to pass an explicit value. If you don't pass one, it will default to false automatically. Implicit and explicit are just ways to pass the value, under the hood they are just boolean parameters.","title":"2. Explicit"},{"location":"V3/argument-arity/","text":"Argument Arity # Arity indicates the number of values an argument can contain. ArgumentArity is defined by a min and max value. When min is 0, then no values are required. When max is greater than 1, then multiple values can be provided. Min is set to 0 when the argument type is Nullable or when defined by an optional parameter. IArgumentModel properties for reference types cannot be inferred to have a Min of 0.","title":"Argument Arity"},{"location":"V3/argument-arity/#argument-arity","text":"Arity indicates the number of values an argument can contain. ArgumentArity is defined by a min and max value. When min is 0, then no values are required. When max is greater than 1, then multiple values can be provided. Min is set to 0 when the argument type is Nullable or when defined by an optional parameter. IArgumentModel properties for reference types cannot be inferred to have a Min of 0.","title":"Argument Arity"},{"location":"V3/argument-terminology/","text":"Argument Terminology # Terminology for arguments is confusing. When should an argument be an option, switch, flag, argument or parameter. Should it be named or positional? Is an option always optional? Part of the confusion is the overloaded nature of of the term argument , as explained in this article . Context determines what is considered an argument. TLDR: The terminology of this framework. Perspectives # Let's look at the git stash store command to see how different perspectives see it. Git help describes the usage as git stash store [ - m | --message <message>] [-q|--quiet] <commit> . Let's say we executed this command as follows: git stash store - q - m 'my stash' e7a8621 Programmatically, the perspectives are: shell: every word is an argument. git stash store - q - m 'my stash' e7a8621 application: the arguments are stash store - q - m 'my stash' e7a8621 , as assigned to Main ( string [] args ) stash command: the arguments are store . Once a subcommand is specified, all remaining arguments are for the subcommand. store command: the arguments are - q - m 'my stash' e7a8621 . Conceptually, the perspectives are: developer: the arguments are - q - m 'my stash' e7a8621 . user: the arguments are e7a8621 . - q and - m are options. Common conventions of help documentation distinguishes options from arguments. CommandDotNet Perspectives # The user of the console app: needs to understand usage, when arguments are named vs positional. The developer of the console app: needs to define arguments that are named vs positional. The developer of middleware components: often need to operate across all command arguments regardless of type. Addressed in the following ways # For users of the console app help documentation is the interface. terminoloy: command , option and argument . For developers terminoloy: command , argument , option and operand types: Command , IArgument , Option and Operand . Option and Operand are the two types of IArgument Option: named argument Operand: positional argument Command contains collections of Option, Operand and Command (as subcommands) Arguments are defined using parameters: of a command method properties: of an IArgumentModel Flags are defined as Options with BooleanMode = Implicit. This is the default for Options of type bool and can be changed using AppSettings . DefaultBooleanMode or OptionAttribute . BooleanMode .","title":"Argument Terminology"},{"location":"V3/argument-terminology/#argument-terminology","text":"Terminology for arguments is confusing. When should an argument be an option, switch, flag, argument or parameter. Should it be named or positional? Is an option always optional? Part of the confusion is the overloaded nature of of the term argument , as explained in this article . Context determines what is considered an argument. TLDR: The terminology of this framework.","title":"Argument Terminology"},{"location":"V3/argument-terminology/#perspectives","text":"Let's look at the git stash store command to see how different perspectives see it. Git help describes the usage as git stash store [ - m | --message <message>] [-q|--quiet] <commit> . Let's say we executed this command as follows: git stash store - q - m 'my stash' e7a8621 Programmatically, the perspectives are: shell: every word is an argument. git stash store - q - m 'my stash' e7a8621 application: the arguments are stash store - q - m 'my stash' e7a8621 , as assigned to Main ( string [] args ) stash command: the arguments are store . Once a subcommand is specified, all remaining arguments are for the subcommand. store command: the arguments are - q - m 'my stash' e7a8621 . Conceptually, the perspectives are: developer: the arguments are - q - m 'my stash' e7a8621 . user: the arguments are e7a8621 . - q and - m are options. Common conventions of help documentation distinguishes options from arguments.","title":"Perspectives"},{"location":"V3/argument-terminology/#commanddotnet-perspectives","text":"The user of the console app: needs to understand usage, when arguments are named vs positional. The developer of the console app: needs to define arguments that are named vs positional. The developer of middleware components: often need to operate across all command arguments regardless of type.","title":"CommandDotNet Perspectives"},{"location":"V3/argument-terminology/#addressed-in-the-following-ways","text":"For users of the console app help documentation is the interface. terminoloy: command , option and argument . For developers terminoloy: command , argument , option and operand types: Command , IArgument , Option and Operand . Option and Operand are the two types of IArgument Option: named argument Operand: positional argument Command contains collections of Option, Operand and Command (as subcommands) Arguments are defined using parameters: of a command method properties: of an IArgumentModel Flags are defined as Options with BooleanMode = Implicit. This is the default for Options of type bool and can be changed using AppSettings . DefaultBooleanMode or OptionAttribute . BooleanMode .","title":"Addressed in the following ways"},{"location":"V3/cancellation/","text":"Ctrl+C and CancellationToken # Console applications should stop gracefully when the user enters Ctrl + C or Ctrl + Break . If your app is consuming the main thread the app will not exit right away. Traditionally, this is solved with a following steps: Create a CancellationTokenSource and make the cancellationTokenSource . Token available for the rest of the app to reference. Subscribe to Console . CancelKeyPress and call cancellationTokenSource . Cancel () when triggered. cancellationToken . IsCancellationRequested will then return true. Check cancellationToken . IsCancellationRequested in any looping code and pass the token to any libraries that check it. Instead of Thread . Sleep (...) , use cancellationToken . WaitHandle . WaitOne (...) or Task . Delay (..., cancellationToken ) Cancellation middleware # CommandDotNet has middleware to simplify this. Configure with appRunner . UseCancellationHandlers (); . The framework will: set the CommandContext . AppConfig . CancellationToken with a new token. the token will be cancelled on Console . CancelKepPress AppDomain . CurrentDomain . ProcessExit AppDomain . CurrentDomain . UnhandledException when UnhandledExceptionEventArgs . IsTerminating == true The framework checks the cancellation token before every step in the pipeline. Using the CancellationToken # The CancellationToken is easy to access in your commands thanks to parameter resolvers . Simply add a parameter to your command or interceptor method. public void MigrateRecords ( CancellationToken cancellationToken , List < int > ids ) { foreach ( int id in ids . TakeWhile (! cancellationToken . IsCancellationRequested )) { MigrateRecord ( id ); } } Tip Remember to pass the CancellationToken to all database, web and service requests that take one.","title":"Ctrl+C and CancellationToken"},{"location":"V3/cancellation/#ctrlc-and-cancellationtoken","text":"Console applications should stop gracefully when the user enters Ctrl + C or Ctrl + Break . If your app is consuming the main thread the app will not exit right away. Traditionally, this is solved with a following steps: Create a CancellationTokenSource and make the cancellationTokenSource . Token available for the rest of the app to reference. Subscribe to Console . CancelKeyPress and call cancellationTokenSource . Cancel () when triggered. cancellationToken . IsCancellationRequested will then return true. Check cancellationToken . IsCancellationRequested in any looping code and pass the token to any libraries that check it. Instead of Thread . Sleep (...) , use cancellationToken . WaitHandle . WaitOne (...) or Task . Delay (..., cancellationToken )","title":"Ctrl+C and CancellationToken"},{"location":"V3/cancellation/#cancellation-middleware","text":"CommandDotNet has middleware to simplify this. Configure with appRunner . UseCancellationHandlers (); . The framework will: set the CommandContext . AppConfig . CancellationToken with a new token. the token will be cancelled on Console . CancelKepPress AppDomain . CurrentDomain . ProcessExit AppDomain . CurrentDomain . UnhandledException when UnhandledExceptionEventArgs . IsTerminating == true The framework checks the cancellation token before every step in the pipeline.","title":"Cancellation middleware"},{"location":"V3/cancellation/#using-the-cancellationtoken","text":"The CancellationToken is easy to access in your commands thanks to parameter resolvers . Simply add a parameter to your command or interceptor method. public void MigrateRecords ( CancellationToken cancellationToken , List < int > ids ) { foreach ( int id in ids . TakeWhile (! cancellationToken . IsCancellationRequested )) { MigrateRecord ( id ); } } Tip Remember to pass the CancellationToken to all database, web and service requests that take one.","title":"Using the CancellationToken"},{"location":"V3/interceptors/","text":"Interceptor methods # Interceptor methods will be executed for all commands and subcommands of a class. Interceptor methods can define options to be provided in the shell. Interceptors cannot define operands because they are positional and positional arguments are only applicable for the target command. Example: Using the following commands, we can request the mathematical base to use for our calculations in one location and all subcommands will use the same base. In the shell: dotnet calculator --radix 2 Add 1 2 public class Calculator { private iCalculator _calculator ; private IConsole _console ; public Task < int > Interceptor ( InterceptorExecutionDelegate next , IConsole console , int radix ,) { _calculator = Factory . GetCalculatorFor ( radix ); _console = console ; return next (); } [Command(Description = \"Adds two numbers\")] public void Add ( int x , int y ) { _console . WriteLine ( _calculator . Add ( x , y )); } [Command(Description = \"Subtracts the second number from the first\")] public void Subtract ( int x , int x ) { _console . WriteLine ( _calculator . Subtract ( y , y )); } } Interceptor methods signatures must follow these rules: public accessor Task < int > return type contain either execution delegate: ExecutionDelegate or InterceptorExecutionDelegate . Method name does not matter. In our examples, we use Interceptor . Examples: public Task < int > MethodName ( ExecutionDelegate next , CommandContext context ) public Task < int > MethodName ( InterceptorExecutionDelegate next ) Inherited options # Inherited options provide a way to assign the interceptor option an an option of the executed subcommand. Using the previous example, change int radix to [ Option ( AssignToExecutableSubcommands = true )] int radix Now in the shell: dotnet calculator Add 1 2 --radix 2 public class Calculator { private iCalculator _calculator ; private IConsole _console ; public Task < int > Interceptor ( InterceptorExecutionDelegate next , IConsole console , [Option(AssignToExecutableSubcommands = true)] int radix ) { _calculator = Factory . GetCalculatorFor ( radix ); _console = console ; return next (); } [Command(Description = \"Adds two numbers\")] public void Add ( int x , int y ) { _console . WriteLine ( _calculator . Add ( x , y )); } [Command(Description = \"Subtracts the second number from the first\")] public void Subtract ( int x , int y ) { _console . WriteLine ( _calculator . Subtract ( x , y )); } } Additional parameters # In addition to defining options, interceptor methods can define parameters of type: CommandContext IConsole CancellationToken Hooks for your commands # Wrap return next () ; in try/catch/finally statements and use the interceptor as pre and post hooks for your commands. public Task < int > Interceptor ( InterceptorExecutionDelegate next ) { prehook (); try { return next (); } catch () { errorhook (); } finally () { posthook (); } } Hierarchy interaction # Interceptor methods will be run for all subcommands, including subcommands of subcommands. If the interceptor should run only for subcommands defined in that class, follow this example to determine if the target command is for the same class instance as the current interceptor method. public Task < int > Interceptor ( InterceptorExecutionDelegate next , CommandContext context ) { if ( context . InvocationPipeline . TargetCommand . Instance == this ) { prehook (); } return next (); }","title":"Interceptor methods"},{"location":"V3/interceptors/#interceptor-methods","text":"Interceptor methods will be executed for all commands and subcommands of a class. Interceptor methods can define options to be provided in the shell. Interceptors cannot define operands because they are positional and positional arguments are only applicable for the target command. Example: Using the following commands, we can request the mathematical base to use for our calculations in one location and all subcommands will use the same base. In the shell: dotnet calculator --radix 2 Add 1 2 public class Calculator { private iCalculator _calculator ; private IConsole _console ; public Task < int > Interceptor ( InterceptorExecutionDelegate next , IConsole console , int radix ,) { _calculator = Factory . GetCalculatorFor ( radix ); _console = console ; return next (); } [Command(Description = \"Adds two numbers\")] public void Add ( int x , int y ) { _console . WriteLine ( _calculator . Add ( x , y )); } [Command(Description = \"Subtracts the second number from the first\")] public void Subtract ( int x , int x ) { _console . WriteLine ( _calculator . Subtract ( y , y )); } } Interceptor methods signatures must follow these rules: public accessor Task < int > return type contain either execution delegate: ExecutionDelegate or InterceptorExecutionDelegate . Method name does not matter. In our examples, we use Interceptor . Examples: public Task < int > MethodName ( ExecutionDelegate next , CommandContext context ) public Task < int > MethodName ( InterceptorExecutionDelegate next )","title":"Interceptor methods"},{"location":"V3/interceptors/#inherited-options","text":"Inherited options provide a way to assign the interceptor option an an option of the executed subcommand. Using the previous example, change int radix to [ Option ( AssignToExecutableSubcommands = true )] int radix Now in the shell: dotnet calculator Add 1 2 --radix 2 public class Calculator { private iCalculator _calculator ; private IConsole _console ; public Task < int > Interceptor ( InterceptorExecutionDelegate next , IConsole console , [Option(AssignToExecutableSubcommands = true)] int radix ) { _calculator = Factory . GetCalculatorFor ( radix ); _console = console ; return next (); } [Command(Description = \"Adds two numbers\")] public void Add ( int x , int y ) { _console . WriteLine ( _calculator . Add ( x , y )); } [Command(Description = \"Subtracts the second number from the first\")] public void Subtract ( int x , int y ) { _console . WriteLine ( _calculator . Subtract ( x , y )); } }","title":"Inherited options"},{"location":"V3/interceptors/#additional-parameters","text":"In addition to defining options, interceptor methods can define parameters of type: CommandContext IConsole CancellationToken","title":"Additional parameters"},{"location":"V3/interceptors/#hooks-for-your-commands","text":"Wrap return next () ; in try/catch/finally statements and use the interceptor as pre and post hooks for your commands. public Task < int > Interceptor ( InterceptorExecutionDelegate next ) { prehook (); try { return next (); } catch () { errorhook (); } finally () { posthook (); } }","title":"Hooks for your commands"},{"location":"V3/interceptors/#hierarchy-interaction","text":"Interceptor methods will be run for all subcommands, including subcommands of subcommands. If the interceptor should run only for subcommands defined in that class, follow this example to determine if the target command is for the same class instance as the current interceptor method. public Task < int > Interceptor ( InterceptorExecutionDelegate next , CommandContext context ) { if ( context . InvocationPipeline . TargetCommand . Instance == this ) { prehook (); } return next (); }","title":"Hierarchy interaction"},{"location":"V3/middleware/","text":"Middleware Pipeline # The architecture uses a middleware pipeline, similar to ASP.NET Core and System.CommandLine . The middleware pipeline is a type of chain of responsibilty pattern . Middleware are components that register a delegate as a step in the pipeline. The delegate is called by the previous delegate and in turn calls the next delegate. With this pattern, a middleware can perform work before and after the call to the next delegate or skip the next delegate if appropriate. Take the Help middleware for example. When - h , --help or -? been specified, the help middleware prints help for the target command and does not call the next middleware. As the middleware executes, it enhances the CommandContext . The CommandContext contains the context relevate to the current command. For example... the tokenizer middleware populates the CommandContext . Tokens property. The parser middleware populates the CommandContext . ParseResults property. The CommandContext is part of the delegate signature and is therefore available for all middleware. Why we use the middleware pattern # Ease of adding new features without touching existing code. Observing Single Resposibility & Open-Closed principals. Ease of extending the framework using external packages. Supports community enhancements while reducing the bloat of the framework code base. Feature tests can exclude middleware that's not relevant to the tests. Middleware Stages # The core functionality of the framework and optional features have been implemented using middleware. One of the classic challenges of using the middleware pattern is understanding the order middleware components should be registered. To address this challenge, the pipeline has been split into eight distinct changes, as seen in the diagram below, four core stages (in green) and four extensibility stages (in yellow). The four core stages contain the core functionality of the framework. After each core stage is complete, the framework guarantees specific parts of the CommandContext are populated. The other four stages are where other middleware will typically be registered, based on CommandContext properties the middleware requires to operate. For example, PromptForMissingOperands is registered in the PostParseInputPreBindValues stage because it depends on the ParseResults . ArgumentValues property being populated in the ParseInput stage. FluentValidation is registerd in the PostBindValuesPreInvoke stage because it relies on the IInvocation . ParameterValues being populated in the BindValues stage. Read more in the intellisense of MiddlewareStages and the properties of the CommandContext classes. Note: DisplayVersion is the only optional middleware in a core stage. Any middleware can be registered in a core stage if needed. In the case of DisplayVersion , the middleware must run before DisplayHelp otherwise help would trigger for the root command when it is not executable. Invocation Pipeline # The invocation pipeline is assembled during the ParseInput stage, captured in CommandContext . InvocationPipeline property and run during the InvokeInvocationPipeline stage. The pipeline consists of interceptor methods and the target command method.","title":"Middleware Pipeline"},{"location":"V3/middleware/#middleware-pipeline","text":"The architecture uses a middleware pipeline, similar to ASP.NET Core and System.CommandLine . The middleware pipeline is a type of chain of responsibilty pattern . Middleware are components that register a delegate as a step in the pipeline. The delegate is called by the previous delegate and in turn calls the next delegate. With this pattern, a middleware can perform work before and after the call to the next delegate or skip the next delegate if appropriate. Take the Help middleware for example. When - h , --help or -? been specified, the help middleware prints help for the target command and does not call the next middleware. As the middleware executes, it enhances the CommandContext . The CommandContext contains the context relevate to the current command. For example... the tokenizer middleware populates the CommandContext . Tokens property. The parser middleware populates the CommandContext . ParseResults property. The CommandContext is part of the delegate signature and is therefore available for all middleware.","title":"Middleware Pipeline"},{"location":"V3/middleware/#why-we-use-the-middleware-pattern","text":"Ease of adding new features without touching existing code. Observing Single Resposibility & Open-Closed principals. Ease of extending the framework using external packages. Supports community enhancements while reducing the bloat of the framework code base. Feature tests can exclude middleware that's not relevant to the tests.","title":"Why we use the middleware pattern"},{"location":"V3/middleware/#middleware-stages","text":"The core functionality of the framework and optional features have been implemented using middleware. One of the classic challenges of using the middleware pattern is understanding the order middleware components should be registered. To address this challenge, the pipeline has been split into eight distinct changes, as seen in the diagram below, four core stages (in green) and four extensibility stages (in yellow). The four core stages contain the core functionality of the framework. After each core stage is complete, the framework guarantees specific parts of the CommandContext are populated. The other four stages are where other middleware will typically be registered, based on CommandContext properties the middleware requires to operate. For example, PromptForMissingOperands is registered in the PostParseInputPreBindValues stage because it depends on the ParseResults . ArgumentValues property being populated in the ParseInput stage. FluentValidation is registerd in the PostBindValuesPreInvoke stage because it relies on the IInvocation . ParameterValues being populated in the BindValues stage. Read more in the intellisense of MiddlewareStages and the properties of the CommandContext classes. Note: DisplayVersion is the only optional middleware in a core stage. Any middleware can be registered in a core stage if needed. In the case of DisplayVersion , the middleware must run before DisplayHelp otherwise help would trigger for the root command when it is not executable.","title":"Middleware Stages"},{"location":"V3/middleware/#invocation-pipeline","text":"The invocation pipeline is assembled during the ParseInput stage, captured in CommandContext . InvocationPipeline property and run during the InvokeInvocationPipeline stage. The pipeline consists of interceptor methods and the target command method.","title":"Invocation Pipeline"},{"location":"V3/option-or-operand/","text":"Option vs Operand # It is not always clear when to use an option vs operand. Below are a couple of strategies to help. Every argument an option. # Set AppSettings . DefaultArgumentMode to ArgumentMode . Option and treat every argument as an option. Advantages User cannot accidently provide arguments in the wrong order Adding arguments is less likely to introduce breaking changes If the console input is logged, it's easier to determine user intent at a glance. Especially for older versions of the command with different arguments Disadvantages More typing for the user. Imagine if you had to type argument names for all git commands... git checkout --branch branch-name instead of git checkout branch - name git push --remote origin --branch branch-name instead of git push origin branch - name Consider how often users will be using these commands. If use will generally be from scripts and automation, use all options for backward compatibility. Operand as \"what\", Option as \"how\" # This approach that can lead to a more elegant design of your commands. Consider operands as \"what\" the command operates on and options as \"how\" the command operates on them, as described in this article . In the example below, x and y are the operands and --radix informs how the numbers are represented in the operations. public void Add ( int x , int y , [ Option ] int? radix ) { Console . WriteLine ( _calculator . Add ( x , y , radix )); } The exercise of distinguishing what vs how can bring clarity to your separation of concerns, leading to a cleaner interface. e.g. Identifying --radix as a \"how\" makes it an obvious candidate to promote to a parent command as shown in interceptors example. Optional Operands # Optional operands are a muddy topic. As a general rule, for simplicity, define them as options on the command. This is especially true if there is more than one. This framework will assign positional arguments in the order they are received so if a user skipped the first optional operand and provided a value for the second one, the framework would still assign the value to the first one because it cannot understand the users intent. By defining these as options, users can specify intent with the name. This is similar to how C# uses optional parameters.","title":"Option vs Operand"},{"location":"V3/option-or-operand/#option-vs-operand","text":"It is not always clear when to use an option vs operand. Below are a couple of strategies to help.","title":"Option vs Operand"},{"location":"V3/option-or-operand/#every-argument-an-option","text":"Set AppSettings . DefaultArgumentMode to ArgumentMode . Option and treat every argument as an option. Advantages User cannot accidently provide arguments in the wrong order Adding arguments is less likely to introduce breaking changes If the console input is logged, it's easier to determine user intent at a glance. Especially for older versions of the command with different arguments Disadvantages More typing for the user. Imagine if you had to type argument names for all git commands... git checkout --branch branch-name instead of git checkout branch - name git push --remote origin --branch branch-name instead of git push origin branch - name Consider how often users will be using these commands. If use will generally be from scripts and automation, use all options for backward compatibility.","title":"Every argument an option."},{"location":"V3/option-or-operand/#operand-as-what-option-as-how","text":"This approach that can lead to a more elegant design of your commands. Consider operands as \"what\" the command operates on and options as \"how\" the command operates on them, as described in this article . In the example below, x and y are the operands and --radix informs how the numbers are represented in the operations. public void Add ( int x , int y , [ Option ] int? radix ) { Console . WriteLine ( _calculator . Add ( x , y , radix )); } The exercise of distinguishing what vs how can bring clarity to your separation of concerns, leading to a cleaner interface. e.g. Identifying --radix as a \"how\" makes it an obvious candidate to promote to a parent command as shown in interceptors example.","title":"Operand as \"what\", Option as \"how\""},{"location":"V3/option-or-operand/#optional-operands","text":"Optional operands are a muddy topic. As a general rule, for simplicity, define them as options on the command. This is especially true if there is more than one. This framework will assign positional arguments in the order they are received so if a user skipped the first optional operand and provided a value for the second one, the framework would still assign the value to the first one because it cannot understand the users intent. By defining these as options, users can specify intent with the name. This is similar to how C# uses optional parameters.","title":"Optional Operands"},{"location":"V3/parameter-resolvers/","text":"Parameter Resolvers # Parameters defined in command and interceptor methods must be a valid paramter type as defined in parameter-types . There are times where your command method needs access to a service in the CommandContext , say to write to the IConsole or perform a loop while checking the CancellationToken . One way to get these is to define an interceptor method with a CommandContext parameter and copy the properties to fields for use in other methods. This quickly gets repetitive and cumbersome. Parameter resolvers are functions that, given a CommandContext , return an instance of a type that can be passed to a command or interceptor method. The types returned are valid types to use in command and interceptor methods and command class constructors. There are three default resolvers for: CommandContext , IConsole & CancellationToken . Example of registering a new parameter resolver for SomeService appRunner . Configure ( b => b . UseParameterResolver ( ctx => ctx . Services . Get < SomeService >())); public class Calculator { private ICalculator _calculator ; public Calculator ( ICalculator calculator ) => _calculator = calculator ; public Task < int > Interceptor ( InterceptorExecutionDelegate next , SomeService someService ) { return next (); } [Command(Description = \"Adds two numbers\")] public void Add ( int value1 , int value2 , IConsole console ) { console . WriteLine ( _calculator . Add ( value1 , value2 )); } [Command(Description = \"Subtracts the second number from the first\")] public void Subtract ( int value1 , int value2 , IConsole console ) { console . WriteLine ( _calculator . Subtract ( value1 , value2 )); } } Warning It will be tempting to use this as a form of dependency injection, but it is a service locator pattern. The DI container will not understand the relationships between your dependencies, limiting the containers usefulness in some cases. Tip Use this feature for middleware and infrasturctural components that can be used without DI.","title":"Parameter Resolvers"},{"location":"V3/parameter-resolvers/#parameter-resolvers","text":"Parameters defined in command and interceptor methods must be a valid paramter type as defined in parameter-types . There are times where your command method needs access to a service in the CommandContext , say to write to the IConsole or perform a loop while checking the CancellationToken . One way to get these is to define an interceptor method with a CommandContext parameter and copy the properties to fields for use in other methods. This quickly gets repetitive and cumbersome. Parameter resolvers are functions that, given a CommandContext , return an instance of a type that can be passed to a command or interceptor method. The types returned are valid types to use in command and interceptor methods and command class constructors. There are three default resolvers for: CommandContext , IConsole & CancellationToken . Example of registering a new parameter resolver for SomeService appRunner . Configure ( b => b . UseParameterResolver ( ctx => ctx . Services . Get < SomeService >())); public class Calculator { private ICalculator _calculator ; public Calculator ( ICalculator calculator ) => _calculator = calculator ; public Task < int > Interceptor ( InterceptorExecutionDelegate next , SomeService someService ) { return next (); } [Command(Description = \"Adds two numbers\")] public void Add ( int value1 , int value2 , IConsole console ) { console . WriteLine ( _calculator . Add ( value1 , value2 )); } [Command(Description = \"Subtracts the second number from the first\")] public void Subtract ( int value1 , int value2 , IConsole console ) { console . WriteLine ( _calculator . Subtract ( value1 , value2 )); } } Warning It will be tempting to use this as a form of dependency injection, but it is a service locator pattern. The DI container will not understand the relationships between your dependencies, limiting the containers usefulness in some cases. Tip Use this feature for middleware and infrasturctural components that can be used without DI.","title":"Parameter Resolvers"},{"location":"V3/passwords/","text":"Passwords # The Password type can be use to define arguments that contain confidential data. Password has two features to the value from being leaked to logs and console output. the value is exposed via the GetPassword () method instead of a property so serializers cannot access the value. ToString () will output ***** if there is a value, otherwise an empty string. This helps identify if a value was provided in logs but gives no indication how many characters, unless it happens to have 5 characters. public class Api { public void Download ( string url , [ Option ] string username , [ Option ] Password password ) { ... } } Prompting # When using Password with the built-in prompting features , password prompts will hide all characters.","title":"Passwords"},{"location":"V3/passwords/#passwords","text":"The Password type can be use to define arguments that contain confidential data. Password has two features to the value from being leaked to logs and console output. the value is exposed via the GetPassword () method instead of a property so serializers cannot access the value. ToString () will output ***** if there is a value, otherwise an empty string. This helps identify if a value was provided in logs but gives no indication how many characters, unless it happens to have 5 characters. public class Api { public void Download ( string url , [ Option ] string username , [ Option ] Password password ) { ... } }","title":"Passwords"},{"location":"V3/passwords/#prompting","text":"When using Password with the built-in prompting features , password prompts will hide all characters.","title":"Prompting"},{"location":"V3/piped-arguments/","text":"Piped Arguments # What is piping? # Piping is a way to pass the console output of a command to another command. A simple example is filtering your history of bash commands for git commands: history | grep git . The pipe | tells the shell you are running a new command and that the new command will take the output of the previous command. In this case, history will output the last N bash commands and grep git will filter the output to only the commands containing \"git\" Piping is a great way to decompose commands into smaller, single-responsibility commands. Tip When you find commands repeating the same options to determine what items to operate on, consider extracting the options into search command that returns ids and then update the other commands take the list of ids. app . exe get - customer - ids --only-active | app.exe migrate-customers In .net console apps, you can check piped input using Console . IsInputRedirected and Console . In . Read___ () . Or... use the AppendPipedInputToOperandList middleware Using the middleware? # First, enable the feature with appRunner . AppendPipedInputToOperandList () . Every command is allowed a single operand list. If one is defined and if piped input is available, it will be appended to this list. If the user pipes input and also specifies values for the operand, the two sources will be concatenated with piped input at the end. Tip All output to the console is piped to the next command. Be sure the command generating the piped output does not include additional logging information.","title":"Piped Arguments"},{"location":"V3/piped-arguments/#piped-arguments","text":"","title":"Piped Arguments"},{"location":"V3/piped-arguments/#what-is-piping","text":"Piping is a way to pass the console output of a command to another command. A simple example is filtering your history of bash commands for git commands: history | grep git . The pipe | tells the shell you are running a new command and that the new command will take the output of the previous command. In this case, history will output the last N bash commands and grep git will filter the output to only the commands containing \"git\" Piping is a great way to decompose commands into smaller, single-responsibility commands. Tip When you find commands repeating the same options to determine what items to operate on, consider extracting the options into search command that returns ids and then update the other commands take the list of ids. app . exe get - customer - ids --only-active | app.exe migrate-customers In .net console apps, you can check piped input using Console . IsInputRedirected and Console . In . Read___ () . Or... use the AppendPipedInputToOperandList middleware","title":"What is piping?"},{"location":"V3/piped-arguments/#using-the-middleware","text":"First, enable the feature with appRunner . AppendPipedInputToOperandList () . Every command is allowed a single operand list. If one is defined and if piped input is available, it will be appended to this list. If the user pipes input and also specifies values for the operand, the two sources will be concatenated with piped input at the end. Tip All output to the console is piped to the next command. Be sure the command generating the piped output does not include additional logging information.","title":"Using the middleware?"},{"location":"V3/prompting/","text":"Prompting Middleware # Enable prompting middleware with: appRunner . UsePrompting (...) Examples can be found in the prompts commands in the example app. IPrompter # This will register a parameter resolver for IPrompter . The IPrompter can prompt for a single value or a list of values. When prompting for a list of values, each entry is on a new line. Entering two empty lines will stop prompting for that value. Use Ctrl+C to exit prompting, setting the out parameter isCancellationRequested to true. Set the isPassword parameter to true to hide the input value. Override the default IPrompter with the prompterOverride paramter prompterOverride : context => new MyPrompter ( context ) Argument Prompting # UsePrompting enables argument prompting by default. Use promptForMissingArguments : false to disable. Prompt text can be overridden using the argumentPromptTextOverride parameter. argumentPromptTextOverride : ( context , argument ) => $ \"{argument.CustomAttributes.Get<MyPromptTextAttribute>().PromptText}\" By default, the arguments that will be prompted are those where argument . Arity . RequiresAtLeastOne () and no value was provided. Arguments defined with nullable types or optional parameters will not be prompted. This behavior can be changed using the argumentFilter parameter. argumentFilter : argument => argument . CustomAttributes . Get < MyPromptTextAttribute >()?. Prompt ?? false Use the Password type hide the input.","title":"Prompting"},{"location":"V3/prompting/#prompting-middleware","text":"Enable prompting middleware with: appRunner . UsePrompting (...) Examples can be found in the prompts commands in the example app.","title":"Prompting Middleware"},{"location":"V3/prompting/#iprompter","text":"This will register a parameter resolver for IPrompter . The IPrompter can prompt for a single value or a list of values. When prompting for a list of values, each entry is on a new line. Entering two empty lines will stop prompting for that value. Use Ctrl+C to exit prompting, setting the out parameter isCancellationRequested to true. Set the isPassword parameter to true to hide the input value. Override the default IPrompter with the prompterOverride paramter prompterOverride : context => new MyPrompter ( context )","title":"IPrompter"},{"location":"V3/prompting/#argument-prompting","text":"UsePrompting enables argument prompting by default. Use promptForMissingArguments : false to disable. Prompt text can be overridden using the argumentPromptTextOverride parameter. argumentPromptTextOverride : ( context , argument ) => $ \"{argument.CustomAttributes.Get<MyPromptTextAttribute>().PromptText}\" By default, the arguments that will be prompted are those where argument . Arity . RequiresAtLeastOne () and no value was provided. Arguments defined with nullable types or optional parameters will not be prompted. This behavior can be changed using the argumentFilter parameter. argumentFilter : argument => argument . CustomAttributes . Get < MyPromptTextAttribute >()?. Prompt ?? false Use the Password type hide the input.","title":"Argument Prompting"},{"location":"V3/response-files/","text":"Response Files # Response files are text files containing arguments that can be replaced by their contents in the command line. Micrsoft uses them in several applications including msbuild and the MIDL compiler . Lets start with an example: public void Interceptor ( string user , string pwd , string url ) { _client . Connect ( user , pwd , url ); } public void Find ( string filter , IConsole console ) { _client . Find ( filter ). ForEach ( i => console . Out . WriteLine ( i . Id )); } public void Migrate ( List < string > ids ) { ids . ForEach ( _client . Migrate ); } This app has 2 commands that would be called like this: Find: --user bob --pwd shhh -url dev.site.com Find isNew Migrate: --user bob --pwd shhh -url dev.site.com Migrate 12 3 44 The credentials could be stored in a file: creds/bobs-creds.rsp # bob's dev creds --user bob --pwd shhhh --url dev.site.com Then the call to Find could be @creds / bobs - creds . rsp Find isNew . The expand - response - files token transformation will replace @creds / bobs - creds . rsp with --user bob --pwd shhhh --url dev.site.com . Rules: The file path must be prefixed with @ Empty lines and lines starting with # are skipped Each line is run through a CommandLineStringSplitter to split arguments while honoring quoted strings Multiple arguments can be specified on a single line Arguments can be specified on multiple lines. Files can have any extension as long as the contents are text. Recipes # There are a number of ways to use response files to improve usability and testiblity of your app. Inter-command communication # Similar to piped arguments , a command could write arguments to a response file for use in another command. As an extra step, the path to the response file could be the piped argument. Resume Session # A long running application could maintain a session file with the last processed key or next key or a list of remaining keys. If the app is cancelled or crashes, the user could start from scratch or select a @session-yyyymmdd.rsp to resume the operation. Fail File # An application can store ids of failed items in failed.txt file that can be used to rerun just the failed items. For example: public void Migrate ([ Option ] string failFilePath , List < string > ids ) { if (! ids . Any ()) { ids = _repo . GetAllIds (); } foreach ( var id in ids ) { try { _client . Migrate ( id ); } catch ( Exception ex ) { Log . Error ( ex ); if ( failFilePath != null ) { File . AppendAllText ( failFilePath , id + Environment . NewLine ); } } } } First run: Migrate --failFilePath failed1.txt to migrate all items and capture failed ids to failed1 . txt Trouble shoot errors and deploy code with bug fixes. Second run: Migrate --failFilePath failed2.txt @failed1.txt to migrate all items in failed1 . txt and capture failed ids to failed2 . txt Rinse and repeat. Testing # Response files can be used like configuration files. You can store them for different testing configurations and share them with your team. This can be more efficient than creating batch scripts because you can change some options or in some cases, reuse the same response file across different commands.","title":"Response Files"},{"location":"V3/response-files/#response-files","text":"Response files are text files containing arguments that can be replaced by their contents in the command line. Micrsoft uses them in several applications including msbuild and the MIDL compiler . Lets start with an example: public void Interceptor ( string user , string pwd , string url ) { _client . Connect ( user , pwd , url ); } public void Find ( string filter , IConsole console ) { _client . Find ( filter ). ForEach ( i => console . Out . WriteLine ( i . Id )); } public void Migrate ( List < string > ids ) { ids . ForEach ( _client . Migrate ); } This app has 2 commands that would be called like this: Find: --user bob --pwd shhh -url dev.site.com Find isNew Migrate: --user bob --pwd shhh -url dev.site.com Migrate 12 3 44 The credentials could be stored in a file: creds/bobs-creds.rsp # bob's dev creds --user bob --pwd shhhh --url dev.site.com Then the call to Find could be @creds / bobs - creds . rsp Find isNew . The expand - response - files token transformation will replace @creds / bobs - creds . rsp with --user bob --pwd shhhh --url dev.site.com . Rules: The file path must be prefixed with @ Empty lines and lines starting with # are skipped Each line is run through a CommandLineStringSplitter to split arguments while honoring quoted strings Multiple arguments can be specified on a single line Arguments can be specified on multiple lines. Files can have any extension as long as the contents are text.","title":"Response Files"},{"location":"V3/response-files/#recipes","text":"There are a number of ways to use response files to improve usability and testiblity of your app.","title":"Recipes"},{"location":"V3/response-files/#inter-command-communication","text":"Similar to piped arguments , a command could write arguments to a response file for use in another command. As an extra step, the path to the response file could be the piped argument.","title":"Inter-command communication"},{"location":"V3/response-files/#resume-session","text":"A long running application could maintain a session file with the last processed key or next key or a list of remaining keys. If the app is cancelled or crashes, the user could start from scratch or select a @session-yyyymmdd.rsp to resume the operation.","title":"Resume Session"},{"location":"V3/response-files/#fail-file","text":"An application can store ids of failed items in failed.txt file that can be used to rerun just the failed items. For example: public void Migrate ([ Option ] string failFilePath , List < string > ids ) { if (! ids . Any ()) { ids = _repo . GetAllIds (); } foreach ( var id in ids ) { try { _client . Migrate ( id ); } catch ( Exception ex ) { Log . Error ( ex ); if ( failFilePath != null ) { File . AppendAllText ( failFilePath , id + Environment . NewLine ); } } } } First run: Migrate --failFilePath failed1.txt to migrate all items and capture failed ids to failed1 . txt Trouble shoot errors and deploy code with bug fixes. Second run: Migrate --failFilePath failed2.txt @failed1.txt to migrate all items in failed1 . txt and capture failed ids to failed2 . txt Rinse and repeat.","title":"Fail File"},{"location":"V3/response-files/#testing","text":"Response files can be used like configuration files. You can store them for different testing configurations and share them with your team. This can be more efficient than creating batch scripts because you can change some options or in some cases, reuse the same response file across different commands.","title":"Testing"},{"location":"V3/v3-changes/","text":"v3 Changes # v3 is a significant rewrite of CommandDotNet. The framework has remained mostly backward compatible for basic scenarios. Anything beyond basic scenarios will encounter a breaking change. We welcome everyones help in testing the changes, providing usability feedback, bugs, missing documentation, etc. Given the scope of changes, it's likely something is missed in this doc. If you notice something, please create an issue or submit a pull request for the docs. Thank you. Check build warnings after updating and update obsolete references. They'll be removed in the next major update. What are the changes? # New architecture # The architecture is now based around a middleware pipeline . Arguments terminology # Argument terminology has been updated and made consistent throughout the framework. The term \"Parameters\" is generally replaced with \"Arguments\". Constructor based dependency injection is now possible # read more below Summary of new features # Response file support HelpTextProvider can be overridden to make targetted changes to a section of help. Test tools , helpful for end-to-end test and testing framework extensions, like middleware components. List operands can be populated from piped arguments . Parameter resolvers . Ctrl+C support with CancellationToken. Arity calculated for arguments and can be updated in middleware. [Password] type added to prevent accidental logging of password values and hide passwords during prompting. Prompt tool can be used directly in methods and honors Password and Ctrl+C and has several extensibility points. Lists parameters can be defined as arrays or enumerables that can be streamed from piped input or files. Piped input can be mapped to operand lists. SimpleInjector container support. IoC runInScope to enable isolated instances in each run. IArgumentModels can be resolved from containers to enabe reuse and populating defaults from configs. Newer Release Alerts to alert users when running an older verion of your application. External dependencies Humanizr and FluentValidation have been extracted to nuget packages: CommandDotNet.NameCasing & CommandDotNet.FluentValidation. Several bugs were fixed along the way. Breaking Changes # We initially tried to roll out this update in backward compatible phases. Due to the scope of changes, that proved more burdonsome that it was worth. We decided the benefits were worth the price of breaking changes. Hopefully you'll agree... maybe not during the update, but shortly there after. In some cases, i.e. renamed attributes, the old method or class has been marked with [ Obsolete ] and warnings will suggest how to upgrade. These will be removed in the next major release, 4 . x There are a set of changes your IDE should be able to help you with. For example, namespaces were updated to reflect their functional purpose. Your IDE will likely suggest the fixes and then you can remove the old namespaces. AppSettings & Configuration # The following have been disabled by default and moved to middelware configurations Version option: appRunner . UseVersionMiddleware () Prompting for missing arguments: appRunner . UsePrompting (...) Name casing: appRunner . UseNameCasing (...) via CommandDotNet.NameCasing Fluent validation: appRunner . UseFluentValidation () via CommandDotNet.FluentValidation nuget Interceptor Methods # Interceptor Methods replace Constructor Options # Constructor-based dependency injection was not possible because constructors were used to define options that can be used for all subcommands defined in that class prevented. Those constructors will need to be replaced with interceptor methods. There are two signatures for interceptor methods. Task < int > Inteceptor ( CommandContext ctx , ExecutionDelegate next , ... ) and Task < int > Inteceptor ( InterceptorExecutionDelegate next , ... ) The method name does not matter. What does matter is the Task < int > return type and use of either ExecutionDelegate or InterceptorExecutionDelegate . The former requires a CommandContext . Options can be defined in these methods but are not required. Interceptor Methods scope includes all ancestor commands # Constructor options were only avialable for subcommands defined within the same class as the constructor. This lead to non-obvious behavior with multi-level subcommands where users could supply options that were never used. Example, let's say we have a console app api . exe for an api and the app mimics the RESTful design of the api. public class Api { public Api ( string url ){ ... } public Users Users { get ; set ; } } public class Users { public void List () } The commands are: ApiApp - the root app, with a constructor defining the option --url Users - command from a nested class List - a method to list the users Usage: api --url {api-url} users list In v2 the Api class would not be instantiated and the --url option would be dropped. v3 fixes this by keeping a pipeline of all interceptors. If you need the old behavior, use the following code to keep only the interceptor in the same class as the target command. appRunner . Configure ( c => c . UseMiddleware (( ctx , next ) => { var pipeline = ctx . InvocationPipeline ; pipeline . AncestorInterceptors = pipeline . All . Where ( s => s . Invocation . MethodInfo . DeclaringType == pipeline . TargetCommand . Invocation . MethodInfo . DeclaringType ) . ToList (); return next ( ctx ); }, MiddlewareStages . PostParseInputPreBindValues )); Configuration # Use AppRunner . Configure for any configuration not located in AppSettings. This includes setting a custom help text provider, dependency resolver, etc. CommandInvoker removed # The middleware pipeline architecture obsoleted the CommandInvoker. Look at the CommandInvokerTests in the repo to see how the feature can be implemented using middleware. Where the CommandInvoker only worked for the command method, the new architecture allows interogating all of the interceptor methods. Prompt for list values # Delimited by line instead of by comma. Enter an empty line to submit the list.","title":"v3 Changes"},{"location":"V3/v3-changes/#v3-changes","text":"v3 is a significant rewrite of CommandDotNet. The framework has remained mostly backward compatible for basic scenarios. Anything beyond basic scenarios will encounter a breaking change. We welcome everyones help in testing the changes, providing usability feedback, bugs, missing documentation, etc. Given the scope of changes, it's likely something is missed in this doc. If you notice something, please create an issue or submit a pull request for the docs. Thank you. Check build warnings after updating and update obsolete references. They'll be removed in the next major update.","title":"v3 Changes"},{"location":"V3/v3-changes/#what-are-the-changes","text":"","title":"What are the changes?"},{"location":"V3/v3-changes/#new-architecture","text":"The architecture is now based around a middleware pipeline .","title":"New architecture"},{"location":"V3/v3-changes/#arguments-terminology","text":"Argument terminology has been updated and made consistent throughout the framework. The term \"Parameters\" is generally replaced with \"Arguments\".","title":"Arguments terminology"},{"location":"V3/v3-changes/#constructor-based-dependency-injection-is-now-possible","text":"read more below","title":"Constructor based dependency injection is now possible"},{"location":"V3/v3-changes/#summary-of-new-features","text":"Response file support HelpTextProvider can be overridden to make targetted changes to a section of help. Test tools , helpful for end-to-end test and testing framework extensions, like middleware components. List operands can be populated from piped arguments . Parameter resolvers . Ctrl+C support with CancellationToken. Arity calculated for arguments and can be updated in middleware. [Password] type added to prevent accidental logging of password values and hide passwords during prompting. Prompt tool can be used directly in methods and honors Password and Ctrl+C and has several extensibility points. Lists parameters can be defined as arrays or enumerables that can be streamed from piped input or files. Piped input can be mapped to operand lists. SimpleInjector container support. IoC runInScope to enable isolated instances in each run. IArgumentModels can be resolved from containers to enabe reuse and populating defaults from configs. Newer Release Alerts to alert users when running an older verion of your application. External dependencies Humanizr and FluentValidation have been extracted to nuget packages: CommandDotNet.NameCasing & CommandDotNet.FluentValidation. Several bugs were fixed along the way.","title":"Summary of new features"},{"location":"V3/v3-changes/#breaking-changes","text":"We initially tried to roll out this update in backward compatible phases. Due to the scope of changes, that proved more burdonsome that it was worth. We decided the benefits were worth the price of breaking changes. Hopefully you'll agree... maybe not during the update, but shortly there after. In some cases, i.e. renamed attributes, the old method or class has been marked with [ Obsolete ] and warnings will suggest how to upgrade. These will be removed in the next major release, 4 . x There are a set of changes your IDE should be able to help you with. For example, namespaces were updated to reflect their functional purpose. Your IDE will likely suggest the fixes and then you can remove the old namespaces.","title":"Breaking Changes"},{"location":"V3/v3-changes/#appsettings-configuration","text":"The following have been disabled by default and moved to middelware configurations Version option: appRunner . UseVersionMiddleware () Prompting for missing arguments: appRunner . UsePrompting (...) Name casing: appRunner . UseNameCasing (...) via CommandDotNet.NameCasing Fluent validation: appRunner . UseFluentValidation () via CommandDotNet.FluentValidation nuget","title":"AppSettings &amp; Configuration"},{"location":"V3/v3-changes/#interceptor-methods","text":"","title":"Interceptor Methods"},{"location":"V3/v3-changes/#interceptor-methods-replace-constructor-options","text":"Constructor-based dependency injection was not possible because constructors were used to define options that can be used for all subcommands defined in that class prevented. Those constructors will need to be replaced with interceptor methods. There are two signatures for interceptor methods. Task < int > Inteceptor ( CommandContext ctx , ExecutionDelegate next , ... ) and Task < int > Inteceptor ( InterceptorExecutionDelegate next , ... ) The method name does not matter. What does matter is the Task < int > return type and use of either ExecutionDelegate or InterceptorExecutionDelegate . The former requires a CommandContext . Options can be defined in these methods but are not required.","title":"Interceptor Methods replace Constructor Options"},{"location":"V3/v3-changes/#interceptor-methods-scope-includes-all-ancestor-commands","text":"Constructor options were only avialable for subcommands defined within the same class as the constructor. This lead to non-obvious behavior with multi-level subcommands where users could supply options that were never used. Example, let's say we have a console app api . exe for an api and the app mimics the RESTful design of the api. public class Api { public Api ( string url ){ ... } public Users Users { get ; set ; } } public class Users { public void List () } The commands are: ApiApp - the root app, with a constructor defining the option --url Users - command from a nested class List - a method to list the users Usage: api --url {api-url} users list In v2 the Api class would not be instantiated and the --url option would be dropped. v3 fixes this by keeping a pipeline of all interceptors. If you need the old behavior, use the following code to keep only the interceptor in the same class as the target command. appRunner . Configure ( c => c . UseMiddleware (( ctx , next ) => { var pipeline = ctx . InvocationPipeline ; pipeline . AncestorInterceptors = pipeline . All . Where ( s => s . Invocation . MethodInfo . DeclaringType == pipeline . TargetCommand . Invocation . MethodInfo . DeclaringType ) . ToList (); return next ( ctx ); }, MiddlewareStages . PostParseInputPreBindValues ));","title":"Interceptor Methods scope includes all ancestor commands"},{"location":"V3/v3-changes/#configuration","text":"Use AppRunner . Configure for any configuration not located in AppSettings. This includes setting a custom help text provider, dependency resolver, etc.","title":"Configuration"},{"location":"V3/v3-changes/#commandinvoker-removed","text":"The middleware pipeline architecture obsoleted the CommandInvoker. Look at the CommandInvokerTests in the repo to see how the feature can be implemented using middleware. Where the CommandInvoker only worked for the command method, the new architecture allows interogating all of the interceptor methods.","title":"CommandInvoker removed"},{"location":"V3/v3-changes/#prompt-for-list-values","text":"Delimited by line instead of by comma. Enter an empty line to submit the list.","title":"Prompt for list values"}]}